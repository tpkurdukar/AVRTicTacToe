
tictactoe.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000144  00800100  00000f1a  00000fae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f1a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000a  00800244  00800244  000010f2  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000010f2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001150  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000b0  00000000  00000000  00001190  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000013a6  00000000  00000000  00001240  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a43  00000000  00000000  000025e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000931  00000000  00000000  00003029  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000200  00000000  00000000  0000395c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000056c  00000000  00000000  00003b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000fab  00000000  00000000  000040c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000080  00000000  00000000  00005073  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	12 e0       	ldi	r17, 0x02	; 2
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ea e1       	ldi	r30, 0x1A	; 26
  7c:	ff e0       	ldi	r31, 0x0F	; 15
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a4 34       	cpi	r26, 0x44	; 68
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	22 e0       	ldi	r18, 0x02	; 2
  8c:	a4 e4       	ldi	r26, 0x44	; 68
  8e:	b2 e0       	ldi	r27, 0x02	; 2
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ae 34       	cpi	r26, 0x4E	; 78
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 9a 00 	call	0x134	; 0x134 <main>
  9e:	0c 94 8b 07 	jmp	0xf16	; 0xf16 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <shift_74HC165>:

/* Shifts in data LSB first */
uint16_t shift_74HC165() {
	
	// use LD pin to take snapshot of current state
	PISO_PORT &= ~(1 << LD); // parallel ld pin is active low
  a6:	43 98       	cbi	0x08, 3	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  a8:	87 ec       	ldi	r24, 0xC7	; 199
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	01 97       	sbiw	r24, 0x01	; 1
  ae:	f1 f7       	brne	.-4      	; 0xac <shift_74HC165+0x6>
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <shift_74HC165+0xc>
  b2:	00 00       	nop
	_delay_us(50);
	PISO_PORT |= (1 << LD);
  b4:	43 9a       	sbi	0x08, 3	; 8
  b6:	e7 ec       	ldi	r30, 0xC7	; 199
  b8:	f0 e0       	ldi	r31, 0x00	; 0
  ba:	31 97       	sbiw	r30, 0x01	; 1
  bc:	f1 f7       	brne	.-4      	; 0xba <shift_74HC165+0x14>
  be:	00 c0       	rjmp	.+0      	; 0xc0 <shift_74HC165+0x1a>
  c0:	00 00       	nop
	_delay_us(50);
	
	PISO_PORT &= ~(1 << CLK_INH); // clear CLK and set inhibit to low
  c2:	44 98       	cbi	0x08, 4	; 8
  c4:	20 e1       	ldi	r18, 0x10	; 16
  c6:	30 e0       	ldi	r19, 0x00	; 0
	uint16_t data = 0;
  c8:	80 e0       	ldi	r24, 0x00	; 0
  ca:	90 e0       	ldi	r25, 0x00	; 0
	for(uint16_t i = 0; i < 16; i++) {
		
		data <<= 1;	
  cc:	88 0f       	add	r24, r24
  ce:	99 1f       	adc	r25, r25
		// if 1 in QH
		if(DATA_PORT & (1 << DATA_IN)) {
  d0:	35 99       	sbic	0x06, 5	; 6
			data |= 1;
  d2:	81 60       	ori	r24, 0x01	; 1
		}
		
		PISO_PORT |= (1 << PISO_CLK); // pulse clk signal
  d4:	42 9a       	sbi	0x08, 2	; 8
  d6:	e7 ec       	ldi	r30, 0xC7	; 199
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	31 97       	sbiw	r30, 0x01	; 1
  dc:	f1 f7       	brne	.-4      	; 0xda <shift_74HC165+0x34>
  de:	00 c0       	rjmp	.+0      	; 0xe0 <shift_74HC165+0x3a>
  e0:	00 00       	nop
		_delay_us(50);
		PISO_PORT &= ~(1 << PISO_CLK);
  e2:	42 98       	cbi	0x08, 2	; 8
  e4:	e7 ec       	ldi	r30, 0xC7	; 199
  e6:	f0 e0       	ldi	r31, 0x00	; 0
  e8:	31 97       	sbiw	r30, 0x01	; 1
  ea:	f1 f7       	brne	.-4      	; 0xe8 <shift_74HC165+0x42>
  ec:	00 c0       	rjmp	.+0      	; 0xee <shift_74HC165+0x48>
  ee:	00 00       	nop
  f0:	21 50       	subi	r18, 0x01	; 1
  f2:	31 09       	sbc	r19, r1
	PISO_PORT |= (1 << LD);
	_delay_us(50);
	
	PISO_PORT &= ~(1 << CLK_INH); // clear CLK and set inhibit to low
	uint16_t data = 0;
	for(uint16_t i = 0; i < 16; i++) {
  f4:	59 f7       	brne	.-42     	; 0xcc <shift_74HC165+0x26>
		_delay_us(50);
		PISO_PORT &= ~(1 << PISO_CLK);
		_delay_us(50);
	} 
	
	PISO_PORT |= (1 << CLK_INH); // set clk inhibit high
  f6:	44 9a       	sbi	0x08, 4	; 8
	return data;
}
  f8:	08 95       	ret

000000fa <shift_74HC595>:

void shift_74HC595(uint16_t data) {
	SIPO_PORT &= ~(1 << LATCH_PIN); // set latch low
  fa:	5d 98       	cbi	0x0b, 5	; 11
  fc:	20 e1       	ldi	r18, 0x10	; 16
  fe:	30 e0       	ldi	r19, 0x00	; 0
		 Take the MSB of the data byte and send it to Qa in the shift reg.
		 Then, pulse the shift reg's clock to cascade the data through.
		 Finally, shift data byte left to check the next bit 
		 Repeat until data byte is exhausted */
		
		if(data & 0b1000000000000000) {
 100:	99 23       	and	r25, r25
 102:	14 f4       	brge	.+4      	; 0x108 <shift_74HC595+0xe>
			SIPO_PORT |= (1 << DS_PIN); // send 1 to Qa
 104:	5f 9a       	sbi	0x0b, 7	; 11
 106:	01 c0       	rjmp	.+2      	; 0x10a <shift_74HC595+0x10>
		} else {
			SIPO_PORT &= ~(1 << DS_PIN); // send 0 to Qa
 108:	5f 98       	cbi	0x0b, 7	; 11
		}
		
		data <<= 1;
 10a:	88 0f       	add	r24, r24
 10c:	99 1f       	adc	r25, r25
		
		SIPO_PORT |= (1 << SIPO_CLK); // rise clk
 10e:	5e 9a       	sbi	0x0b, 6	; 11
 110:	e7 ec       	ldi	r30, 0xC7	; 199
 112:	f0 e0       	ldi	r31, 0x00	; 0
 114:	31 97       	sbiw	r30, 0x01	; 1
 116:	f1 f7       	brne	.-4      	; 0x114 <shift_74HC595+0x1a>
 118:	00 c0       	rjmp	.+0      	; 0x11a <shift_74HC595+0x20>
 11a:	00 00       	nop
		_delay_us(50);
		SIPO_PORT &= ~(1 << SIPO_CLK); // drop clk signal
 11c:	5e 98       	cbi	0x0b, 6	; 11
 11e:	e7 ec       	ldi	r30, 0xC7	; 199
 120:	f0 e0       	ldi	r31, 0x00	; 0
 122:	31 97       	sbiw	r30, 0x01	; 1
 124:	f1 f7       	brne	.-4      	; 0x122 <shift_74HC595+0x28>
 126:	00 c0       	rjmp	.+0      	; 0x128 <shift_74HC595+0x2e>
 128:	00 00       	nop
 12a:	21 50       	subi	r18, 0x01	; 1
 12c:	31 09       	sbc	r19, r1
}

void shift_74HC595(uint16_t data) {
	SIPO_PORT &= ~(1 << LATCH_PIN); // set latch low
	
	for(uint16_t i = 0; i < 16; i++) {
 12e:	41 f7       	brne	.-48     	; 0x100 <shift_74HC595+0x6>
		_delay_us(50);
		SIPO_PORT &= ~(1 << SIPO_CLK); // drop clk signal
		_delay_us(50);
	}
	
	SIPO_PORT |= (1 << LATCH_PIN); // display output
 130:	5d 9a       	sbi	0x0b, 5	; 11
 132:	08 95       	ret

00000134 <main>:
uint16_t shift_74HC165(); 

/* line pulled from: https://www.sparkfun.com/tutorials/105 */
static FILE mystdout = FDEV_SETUP_STREAM(USART_putchar, NULL, _FDEV_SETUP_WRITE);
int main(void)
{
 134:	cf 93       	push	r28
 136:	df 93       	push	r29
 138:	00 d0       	rcall	.+0      	; 0x13a <main+0x6>
 13a:	00 d0       	rcall	.+0      	; 0x13c <main+0x8>
 13c:	cd b7       	in	r28, 0x3d	; 61
 13e:	de b7       	in	r29, 0x3e	; 62
	USART_init();
 140:	0e 94 43 03 	call	0x686	; 0x686 <USART_init>
	stdout = &mystdout; //necessary to use printf
 144:	86 e0       	ldi	r24, 0x06	; 6
 146:	91 e0       	ldi	r25, 0x01	; 1
 148:	90 93 4b 02 	sts	0x024B, r25	; 0x80024b <__iob+0x3>
 14c:	80 93 4a 02 	sts	0x024A, r24	; 0x80024a <__iob+0x2>
	
	char** game = init_board();
 150:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <init_board>
 154:	6c 01       	movw	r12, r24
	uint16_t new_bits = 0, old_bits = 0;
	uint8_t changed_pos, flag = 0; // flag is active when it is necessary to restore the board to a previous state
	uint16_t end_game_pattern = 0;
	
	/* initialize shift registers */
	PISO_DDR = (1 << LD) | (1 << PISO_CLK) | (1 << CLK_INH); // note DATA_IN is set as input
 156:	8c e1       	ldi	r24, 0x1C	; 28
 158:	87 b9       	out	0x07, r24	; 7
	SIPO_DDR = (1 << LATCH_PIN) | (1 << SIPO_CLK) | (1 << DS_PIN);
 15a:	80 ee       	ldi	r24, 0xE0	; 224
 15c:	8a b9       	out	0x0a, r24	; 10
	shift_74HC595(0);
 15e:	80 e0       	ldi	r24, 0x00	; 0
 160:	90 e0       	ldi	r25, 0x00	; 0
 162:	0e 94 7d 00 	call	0xfa	; 0xfa <shift_74HC595>
	while(shift_74HC165()) {
 166:	04 c0       	rjmp	.+8      	; 0x170 <main+0x3c>
		printf("Clear the board.\r\n");
 168:	84 e2       	ldi	r24, 0x24	; 36
 16a:	91 e0       	ldi	r25, 0x01	; 1
 16c:	0e 94 93 04 	call	0x926	; 0x926 <puts>
	
	/* initialize shift registers */
	PISO_DDR = (1 << LD) | (1 << PISO_CLK) | (1 << CLK_INH); // note DATA_IN is set as input
	SIPO_DDR = (1 << LATCH_PIN) | (1 << SIPO_CLK) | (1 << DS_PIN);
	shift_74HC595(0);
	while(shift_74HC165()) {
 170:	0e 94 53 00 	call	0xa6	; 0xa6 <shift_74HC165>
 174:	89 2b       	or	r24, r25
 176:	c1 f7       	brne	.-16     	; 0x168 <main+0x34>
 178:	1a 82       	std	Y+2, r1	; 0x02
 17a:	19 82       	std	Y+1, r1	; 0x01
 17c:	71 2c       	mov	r7, r1
 17e:	00 e0       	ldi	r16, 0x00	; 0
 180:	10 e0       	ldi	r17, 0x00	; 0
 182:	1c 82       	std	Y+4, r1	; 0x04
 184:	1b 82       	std	Y+3, r1	; 0x03
 186:	0f 2e       	mov	r0, r31
 188:	f8 e7       	ldi	r31, 0x78	; 120
 18a:	6f 2e       	mov	r6, r31
 18c:	f0 2d       	mov	r31, r0
			_delay_ms(200);
			continue;
		} else {
			// display information on terminal if game running normally
			display_board(game);
			printf("\r\nCurrent player: %c\r\n", player);
 18e:	0f 2e       	mov	r0, r31
 190:	f6 e3       	ldi	r31, 0x36	; 54
 192:	ef 2e       	mov	r14, r31
 194:	f1 e0       	ldi	r31, 0x01	; 1
 196:	ff 2e       	mov	r15, r31
 198:	f0 2d       	mov	r31, r0
			_delay_ms(200);
		}
		
		changed_pos = find_changed_bit(old_bits, new_bits); // locate the changed bit
		
		flag = 1;
 19a:	55 24       	eor	r5, r5
 19c:	53 94       	inc	r5
			default:
				flag = 0;
		}
		
		_delay_ms(200);
		shift_74HC595((1 << changed_pos));
 19e:	88 24       	eor	r8, r8
 1a0:	83 94       	inc	r8
 1a2:	91 2c       	mov	r9, r1
		shift_74HC595(0);
		
		row = changed_pos / 3;
		col = changed_pos % 3;
		// update board, previously stored bits
		update_board(game, player, row, col);
 1a4:	0f 2e       	mov	r0, r31
 1a6:	fb ea       	ldi	r31, 0xAB	; 171
 1a8:	3f 2e       	mov	r3, r31
 1aa:	f0 2d       	mov	r31, r0
	
    while (1) {
		if(flag) {
			// player disrupted the game board, does not proceed until they return to the previous state of the board
			if(new_bits == old_bits) {
				flag = 0;
 1ac:	41 2c       	mov	r4, r1
 1ae:	06 c0       	rjmp	.+12     	; 0x1bc <main+0x88>
 1b0:	0b 81       	ldd	r16, Y+3	; 0x03
 1b2:	1c 81       	ldd	r17, Y+4	; 0x04
			remake_board(game);
			old_bits = 0, new_bits = 0;
			continue;
		}

		(player == 'x') ? (player = 'o') : (player = 'x');
 1b4:	0f 2e       	mov	r0, r31
 1b6:	ff e6       	ldi	r31, 0x6F	; 111
 1b8:	6f 2e       	mov	r6, r31
 1ba:	f0 2d       	mov	r31, r0
	while(shift_74HC165()) {
		printf("Clear the board.\r\n");
	}
	
    while (1) {
		if(flag) {
 1bc:	77 20       	and	r7, r7
 1be:	a1 f0       	breq	.+40     	; 0x1e8 <main+0xb4>
			// player disrupted the game board, does not proceed until they return to the previous state of the board
			if(new_bits == old_bits) {
 1c0:	8b 81       	ldd	r24, Y+3	; 0x03
 1c2:	9c 81       	ldd	r25, Y+4	; 0x04
 1c4:	80 17       	cp	r24, r16
 1c6:	91 07       	cpc	r25, r17
 1c8:	09 f4       	brne	.+2      	; 0x1cc <main+0x98>
				flag = 0;
 1ca:	74 2c       	mov	r7, r4
			}
			new_bits = shift_74HC165();
 1cc:	0e 94 53 00 	call	0xa6	; 0xa6 <shift_74HC165>
 1d0:	9c 83       	std	Y+4, r25	; 0x04
 1d2:	8b 83       	std	Y+3, r24	; 0x03
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1d4:	9f ef       	ldi	r25, 0xFF	; 255
 1d6:	23 ec       	ldi	r18, 0xC3	; 195
 1d8:	89 e0       	ldi	r24, 0x09	; 9
 1da:	91 50       	subi	r25, 0x01	; 1
 1dc:	20 40       	sbci	r18, 0x00	; 0
 1de:	80 40       	sbci	r24, 0x00	; 0
 1e0:	e1 f7       	brne	.-8      	; 0x1da <main+0xa6>
 1e2:	00 c0       	rjmp	.+0      	; 0x1e4 <main+0xb0>
 1e4:	00 00       	nop
			_delay_ms(200);
			continue;
 1e6:	ea cf       	rjmp	.-44     	; 0x1bc <main+0x88>
		} else {
			// display information on terminal if game running normally
			display_board(game);
 1e8:	c6 01       	movw	r24, r12
 1ea:	0e 94 0e 02 	call	0x41c	; 0x41c <display_board>
			printf("\r\nCurrent player: %c\r\n", player);
 1ee:	a6 2c       	mov	r10, r6
 1f0:	b1 2c       	mov	r11, r1
 1f2:	1f 92       	push	r1
 1f4:	6f 92       	push	r6
 1f6:	ff 92       	push	r15
 1f8:	ef 92       	push	r14
 1fa:	0e 94 7d 04 	call	0x8fa	; 0x8fa <printf>
			printf("Waiting for input...\r\n");
 1fe:	8d e4       	ldi	r24, 0x4D	; 77
 200:	91 e0       	ldi	r25, 0x01	; 1
 202:	0e 94 93 04 	call	0x926	; 0x926 <puts>
		}
		
		while(new_bits == old_bits) {
 206:	0f 90       	pop	r0
 208:	0f 90       	pop	r0
 20a:	0f 90       	pop	r0
 20c:	0f 90       	pop	r0
 20e:	8b 81       	ldd	r24, Y+3	; 0x03
 210:	9c 81       	ldd	r25, Y+4	; 0x04
 212:	80 17       	cp	r24, r16
 214:	91 07       	cpc	r25, r17
 216:	91 f4       	brne	.+36     	; 0x23c <main+0x108>
			new_bits = shift_74HC165(); //load new bits
 218:	0e 94 53 00 	call	0xa6	; 0xa6 <shift_74HC165>
 21c:	9c 83       	std	Y+4, r25	; 0x04
 21e:	8b 83       	std	Y+3, r24	; 0x03
 220:	9f ef       	ldi	r25, 0xFF	; 255
 222:	23 ec       	ldi	r18, 0xC3	; 195
 224:	89 e0       	ldi	r24, 0x09	; 9
 226:	91 50       	subi	r25, 0x01	; 1
 228:	20 40       	sbci	r18, 0x00	; 0
 22a:	80 40       	sbci	r24, 0x00	; 0
 22c:	e1 f7       	brne	.-8      	; 0x226 <main+0xf2>
 22e:	00 c0       	rjmp	.+0      	; 0x230 <main+0xfc>
 230:	00 00       	nop
			display_board(game);
			printf("\r\nCurrent player: %c\r\n", player);
			printf("Waiting for input...\r\n");
		}
		
		while(new_bits == old_bits) {
 232:	8b 81       	ldd	r24, Y+3	; 0x03
 234:	9c 81       	ldd	r25, Y+4	; 0x04
 236:	08 17       	cp	r16, r24
 238:	19 07       	cpc	r17, r25
 23a:	71 f3       	breq	.-36     	; 0x218 <main+0xe4>
			new_bits = shift_74HC165(); //load new bits
			_delay_ms(200);
		}
		
		changed_pos = find_changed_bit(old_bits, new_bits); // locate the changed bit
 23c:	6b 81       	ldd	r22, Y+3	; 0x03
 23e:	7c 81       	ldd	r23, Y+4	; 0x04
 240:	c8 01       	movw	r24, r16
 242:	0e 94 9e 02 	call	0x53c	; 0x53c <find_changed_bit>
 246:	28 2e       	mov	r2, r24
		
		flag = 1;
		switch(changed_pos) {
 248:	9b e0       	ldi	r25, 0x0B	; 11
 24a:	89 17       	cp	r24, r25
 24c:	61 f0       	breq	.+24     	; 0x266 <main+0x132>
 24e:	2c e0       	ldi	r18, 0x0C	; 12
 250:	82 17       	cp	r24, r18
 252:	79 f0       	breq	.+30     	; 0x272 <main+0x13e>
 254:	8a e0       	ldi	r24, 0x0A	; 10
 256:	28 12       	cpse	r2, r24
 258:	12 c0       	rjmp	.+36     	; 0x27e <main+0x14a>
			case 0x0A:
				printf("Space already occupied.\r\n");
 25a:	83 e6       	ldi	r24, 0x63	; 99
 25c:	91 e0       	ldi	r25, 0x01	; 1
 25e:	0e 94 93 04 	call	0x926	; 0x926 <puts>
			_delay_ms(200);
		}
		
		changed_pos = find_changed_bit(old_bits, new_bits); // locate the changed bit
		
		flag = 1;
 262:	75 2c       	mov	r7, r5
		switch(changed_pos) {
			case 0x0A:
				printf("Space already occupied.\r\n");
				continue;
 264:	ab cf       	rjmp	.-170    	; 0x1bc <main+0x88>
			case 0x0B:
				printf("Player put two or more pieces on at once. Remove those pieces and try again\r\n");
 266:	8c e7       	ldi	r24, 0x7C	; 124
 268:	91 e0       	ldi	r25, 0x01	; 1
 26a:	0e 94 93 04 	call	0x926	; 0x926 <puts>
			_delay_ms(200);
		}
		
		changed_pos = find_changed_bit(old_bits, new_bits); // locate the changed bit
		
		flag = 1;
 26e:	75 2c       	mov	r7, r5
			case 0x0A:
				printf("Space already occupied.\r\n");
				continue;
			case 0x0B:
				printf("Player put two or more pieces on at once. Remove those pieces and try again\r\n");
				continue;
 270:	a5 cf       	rjmp	.-182    	; 0x1bc <main+0x88>
			case 0x0C:
				printf("Player removed a piece. Put it back bruh\r\n");
 272:	89 ec       	ldi	r24, 0xC9	; 201
 274:	91 e0       	ldi	r25, 0x01	; 1
 276:	0e 94 93 04 	call	0x926	; 0x926 <puts>
			_delay_ms(200);
		}
		
		changed_pos = find_changed_bit(old_bits, new_bits); // locate the changed bit
		
		flag = 1;
 27a:	75 2c       	mov	r7, r5
			case 0x0B:
				printf("Player put two or more pieces on at once. Remove those pieces and try again\r\n");
				continue;
			case 0x0C:
				printf("Player removed a piece. Put it back bruh\r\n");
				continue;
 27c:	9f cf       	rjmp	.-194    	; 0x1bc <main+0x88>
 27e:	9f ef       	ldi	r25, 0xFF	; 255
 280:	23 ec       	ldi	r18, 0xC3	; 195
 282:	89 e0       	ldi	r24, 0x09	; 9
 284:	91 50       	subi	r25, 0x01	; 1
 286:	20 40       	sbci	r18, 0x00	; 0
 288:	80 40       	sbci	r24, 0x00	; 0
 28a:	e1 f7       	brne	.-8      	; 0x284 <main+0x150>
 28c:	00 c0       	rjmp	.+0      	; 0x28e <main+0x15a>
 28e:	00 00       	nop
			default:
				flag = 0;
		}
		
		_delay_ms(200);
		shift_74HC595((1 << changed_pos));
 290:	c4 01       	movw	r24, r8
 292:	02 2c       	mov	r0, r2
 294:	02 c0       	rjmp	.+4      	; 0x29a <main+0x166>
 296:	88 0f       	add	r24, r24
 298:	99 1f       	adc	r25, r25
 29a:	0a 94       	dec	r0
 29c:	e2 f7       	brpl	.-8      	; 0x296 <main+0x162>
 29e:	0e 94 7d 00 	call	0xfa	; 0xfa <shift_74HC595>
 2a2:	9f ef       	ldi	r25, 0xFF	; 255
 2a4:	29 e6       	ldi	r18, 0x69	; 105
 2a6:	88 e1       	ldi	r24, 0x18	; 24
 2a8:	91 50       	subi	r25, 0x01	; 1
 2aa:	20 40       	sbci	r18, 0x00	; 0
 2ac:	80 40       	sbci	r24, 0x00	; 0
 2ae:	e1 f7       	brne	.-8      	; 0x2a8 <main+0x174>
 2b0:	00 c0       	rjmp	.+0      	; 0x2b2 <main+0x17e>
 2b2:	00 00       	nop
		_delay_ms(500);
		shift_74HC595(0);
 2b4:	80 e0       	ldi	r24, 0x00	; 0
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	0e 94 7d 00 	call	0xfa	; 0xfa <shift_74HC595>
		
		row = changed_pos / 3;
		col = changed_pos % 3;
		// update board, previously stored bits
		update_board(game, player, row, col);
 2bc:	23 9c       	mul	r2, r3
 2be:	41 2d       	mov	r20, r1
 2c0:	11 24       	eor	r1, r1
 2c2:	46 95       	lsr	r20
 2c4:	84 2f       	mov	r24, r20
 2c6:	88 0f       	add	r24, r24
 2c8:	84 0f       	add	r24, r20
 2ca:	22 2d       	mov	r18, r2
 2cc:	28 1b       	sub	r18, r24
 2ce:	66 2d       	mov	r22, r6
 2d0:	c6 01       	movw	r24, r12
 2d2:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <update_board>
		old_bits = new_bits;
		
		uint16_t victory = check_victory(game, player);
 2d6:	66 2d       	mov	r22, r6
 2d8:	c6 01       	movw	r24, r12
 2da:	0e 94 0b 03 	call	0x616	; 0x616 <check_victory>
 2de:	8c 01       	movw	r16, r24
		
		if(victory) {
 2e0:	89 2b       	or	r24, r25
 2e2:	69 f0       	breq	.+26     	; 0x2fe <main+0x1ca>
			printf("%c wins. Press clear the board\r\n", player);	
 2e4:	bf 92       	push	r11
 2e6:	af 92       	push	r10
 2e8:	83 ef       	ldi	r24, 0xF3	; 243
 2ea:	91 e0       	ldi	r25, 0x01	; 1
 2ec:	9f 93       	push	r25
 2ee:	8f 93       	push	r24
 2f0:	0e 94 7d 04 	call	0x8fa	; 0x8fa <printf>
 2f4:	0f 90       	pop	r0
 2f6:	0f 90       	pop	r0
 2f8:	0f 90       	pop	r0
 2fa:	0f 90       	pop	r0
 2fc:	17 c0       	rjmp	.+46     	; 0x32c <main+0x1f8>
			end_game_pattern = victory;
		} else if(!(0x01FF - (new_bits & 0x01FF))) {
 2fe:	8b 81       	ldd	r24, Y+3	; 0x03
 300:	9c 81       	ldd	r25, Y+4	; 0x04
 302:	80 95       	com	r24
 304:	90 95       	com	r25
 306:	91 70       	andi	r25, 0x01	; 1
 308:	89 2b       	or	r24, r25
 30a:	59 f4       	brne	.+22     	; 0x322 <main+0x1ee>
			printf("Draw. Please clear the board\r\n.");
 30c:	84 e1       	ldi	r24, 0x14	; 20
 30e:	92 e0       	ldi	r25, 0x02	; 2
 310:	9f 93       	push	r25
 312:	8f 93       	push	r24
 314:	0e 94 7d 04 	call	0x8fa	; 0x8fa <printf>
 318:	0f 90       	pop	r0
 31a:	0f 90       	pop	r0
			end_game_pattern = 0x01FF;
 31c:	0f ef       	ldi	r16, 0xFF	; 255
 31e:	11 e0       	ldi	r17, 0x01	; 1
 320:	05 c0       	rjmp	.+10     	; 0x32c <main+0x1f8>
		}
		
		// wait for all inputs to zero
		if(end_game_pattern) {
 322:	89 81       	ldd	r24, Y+1	; 0x01
 324:	9a 81       	ldd	r25, Y+2	; 0x02
 326:	00 97       	sbiw	r24, 0x00	; 0
 328:	81 f1       	breq	.+96     	; 0x38a <main+0x256>
 32a:	8c 01       	movw	r16, r24
			display_board(game);
 32c:	c6 01       	movw	r24, r12
 32e:	0e 94 0e 02 	call	0x41c	; 0x41c <display_board>
			while(shift_74HC165()) {
 332:	19 c0       	rjmp	.+50     	; 0x366 <main+0x232>
				shift_74HC595(end_game_pattern);
 334:	c8 01       	movw	r24, r16
 336:	0e 94 7d 00 	call	0xfa	; 0xfa <shift_74HC595>
 33a:	9f ef       	ldi	r25, 0xFF	; 255
 33c:	25 ea       	ldi	r18, 0xA5	; 165
 33e:	8e e0       	ldi	r24, 0x0E	; 14
 340:	91 50       	subi	r25, 0x01	; 1
 342:	20 40       	sbci	r18, 0x00	; 0
 344:	80 40       	sbci	r24, 0x00	; 0
 346:	e1 f7       	brne	.-8      	; 0x340 <main+0x20c>
 348:	00 c0       	rjmp	.+0      	; 0x34a <main+0x216>
 34a:	00 00       	nop
				_delay_ms(300);
				shift_74HC595(0);
 34c:	80 e0       	ldi	r24, 0x00	; 0
 34e:	90 e0       	ldi	r25, 0x00	; 0
 350:	0e 94 7d 00 	call	0xfa	; 0xfa <shift_74HC595>
 354:	9f ef       	ldi	r25, 0xFF	; 255
 356:	25 ea       	ldi	r18, 0xA5	; 165
 358:	8e e0       	ldi	r24, 0x0E	; 14
 35a:	91 50       	subi	r25, 0x01	; 1
 35c:	20 40       	sbci	r18, 0x00	; 0
 35e:	80 40       	sbci	r24, 0x00	; 0
 360:	e1 f7       	brne	.-8      	; 0x35a <main+0x226>
 362:	00 c0       	rjmp	.+0      	; 0x364 <main+0x230>
 364:	00 00       	nop
		}
		
		// wait for all inputs to zero
		if(end_game_pattern) {
			display_board(game);
			while(shift_74HC165()) {
 366:	0e 94 53 00 	call	0xa6	; 0xa6 <shift_74HC165>
 36a:	89 2b       	or	r24, r25
 36c:	19 f7       	brne	.-58     	; 0x334 <main+0x200>
				shift_74HC595(0);
				_delay_ms(300);
			}
					
			player = 'x';
			remake_board(game);
 36e:	c6 01       	movw	r24, r12
 370:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <remake_board>
			old_bits = 0, new_bits = 0;
			continue;
 374:	1a 83       	std	Y+2, r17	; 0x02
 376:	09 83       	std	Y+1, r16	; 0x01
				_delay_ms(300);
			}
					
			player = 'x';
			remake_board(game);
			old_bits = 0, new_bits = 0;
 378:	00 e0       	ldi	r16, 0x00	; 0
 37a:	10 e0       	ldi	r17, 0x00	; 0
 37c:	1c 82       	std	Y+4, r1	; 0x04
 37e:	1b 82       	std	Y+3, r1	; 0x03
				_delay_ms(300);
				shift_74HC595(0);
				_delay_ms(300);
			}
					
			player = 'x';
 380:	0f 2e       	mov	r0, r31
 382:	f8 e7       	ldi	r31, 0x78	; 120
 384:	6f 2e       	mov	r6, r31
 386:	f0 2d       	mov	r31, r0
			remake_board(game);
			old_bits = 0, new_bits = 0;
			continue;
 388:	19 cf       	rjmp	.-462    	; 0x1bc <main+0x88>
		}

		(player == 'x') ? (player = 'o') : (player = 'x');
 38a:	98 e7       	ldi	r25, 0x78	; 120
 38c:	69 16       	cp	r6, r25
 38e:	09 f4       	brne	.+2      	; 0x392 <main+0x25e>
 390:	0f cf       	rjmp	.-482    	; 0x1b0 <main+0x7c>
 392:	0b 81       	ldd	r16, Y+3	; 0x03
 394:	1c 81       	ldd	r17, Y+4	; 0x04
 396:	0f 2e       	mov	r0, r31
 398:	f8 e7       	ldi	r31, 0x78	; 120
 39a:	6f 2e       	mov	r6, r31
 39c:	f0 2d       	mov	r31, r0
 39e:	0e cf       	rjmp	.-484    	; 0x1bc <main+0x88>

000003a0 <init_board>:
#include "tictactoefunctions.h"

/* Initializes a 3x3 board as a 2d array and returns address */
char** init_board() {
 3a0:	cf 92       	push	r12
 3a2:	df 92       	push	r13
 3a4:	ef 92       	push	r14
 3a6:	ff 92       	push	r15
 3a8:	0f 93       	push	r16
 3aa:	1f 93       	push	r17
 3ac:	cf 93       	push	r28
    char** board = (char**) malloc(3 * sizeof(char*));
 3ae:	86 e0       	ldi	r24, 0x06	; 6
 3b0:	90 e0       	ldi	r25, 0x00	; 0
 3b2:	0e 94 57 03 	call	0x6ae	; 0x6ae <malloc>
 3b6:	6c 01       	movw	r12, r24
 3b8:	8c 01       	movw	r16, r24
 3ba:	7c 01       	movw	r14, r24
 3bc:	86 e0       	ldi	r24, 0x06	; 6
 3be:	e8 0e       	add	r14, r24
 3c0:	f1 1c       	adc	r15, r1
    uint8_t i, j;
    for(i = 0; i < 3; i++) {
        board[i] = (char*) malloc(3 * sizeof(char));
        for(j = 0; j < 3; j++) {
            board[i][j] = '-';
 3c2:	cd e2       	ldi	r28, 0x2D	; 45
/* Initializes a 3x3 board as a 2d array and returns address */
char** init_board() {
    char** board = (char**) malloc(3 * sizeof(char*));
    uint8_t i, j;
    for(i = 0; i < 3; i++) {
        board[i] = (char*) malloc(3 * sizeof(char));
 3c4:	83 e0       	ldi	r24, 0x03	; 3
 3c6:	90 e0       	ldi	r25, 0x00	; 0
 3c8:	0e 94 57 03 	call	0x6ae	; 0x6ae <malloc>
 3cc:	fc 01       	movw	r30, r24
 3ce:	d8 01       	movw	r26, r16
 3d0:	8d 93       	st	X+, r24
 3d2:	9d 93       	st	X+, r25
 3d4:	8d 01       	movw	r16, r26
        for(j = 0; j < 3; j++) {
            board[i][j] = '-';
 3d6:	c0 83       	st	Z, r28
 3d8:	c1 83       	std	Z+1, r28	; 0x01
 3da:	c2 83       	std	Z+2, r28	; 0x02

/* Initializes a 3x3 board as a 2d array and returns address */
char** init_board() {
    char** board = (char**) malloc(3 * sizeof(char*));
    uint8_t i, j;
    for(i = 0; i < 3; i++) {
 3dc:	ae 15       	cp	r26, r14
 3de:	bf 05       	cpc	r27, r15
 3e0:	89 f7       	brne	.-30     	; 0x3c4 <init_board+0x24>
            board[i][j] = '-';
        }
    }

    return board;
}
 3e2:	c6 01       	movw	r24, r12
 3e4:	cf 91       	pop	r28
 3e6:	1f 91       	pop	r17
 3e8:	0f 91       	pop	r16
 3ea:	ff 90       	pop	r15
 3ec:	ef 90       	pop	r14
 3ee:	df 90       	pop	r13
 3f0:	cf 90       	pop	r12
 3f2:	08 95       	ret

000003f4 <remake_board>:


/* Clears the board */
void remake_board(char** board) {
 3f4:	fc 01       	movw	r30, r24
 3f6:	9c 01       	movw	r18, r24
 3f8:	2a 5f       	subi	r18, 0xFA	; 250
 3fa:	3f 4f       	sbci	r19, 0xFF	; 255
    uint8_t i, j;

    for(i = 0; i < 3; i++) {
        for(j = 0; j < 3; j++) {
            board[i][j] = '-'; // initialize board to clear array
 3fc:	8d e2       	ldi	r24, 0x2D	; 45
 3fe:	a0 81       	ld	r26, Z
 400:	b1 81       	ldd	r27, Z+1	; 0x01
 402:	8c 93       	st	X, r24
 404:	a0 81       	ld	r26, Z
 406:	b1 81       	ldd	r27, Z+1	; 0x01
 408:	11 96       	adiw	r26, 0x01	; 1
 40a:	8c 93       	st	X, r24
 40c:	a1 91       	ld	r26, Z+
 40e:	b1 91       	ld	r27, Z+
 410:	12 96       	adiw	r26, 0x02	; 2
 412:	8c 93       	st	X, r24

/* Clears the board */
void remake_board(char** board) {
    uint8_t i, j;

    for(i = 0; i < 3; i++) {
 414:	2e 17       	cp	r18, r30
 416:	3f 07       	cpc	r19, r31
 418:	91 f7       	brne	.-28     	; 0x3fe <remake_board+0xa>
        for(j = 0; j < 3; j++) {
            board[i][j] = '-'; // initialize board to clear array
        }
    }
} 
 41a:	08 95       	ret

0000041c <display_board>:

/* Displays board on console w/ grid */
void display_board(char** board) {
 41c:	af 92       	push	r10
 41e:	bf 92       	push	r11
 420:	cf 92       	push	r12
 422:	df 92       	push	r13
 424:	ef 92       	push	r14
 426:	ff 92       	push	r15
 428:	0f 93       	push	r16
 42a:	1f 93       	push	r17
 42c:	cf 93       	push	r28
 42e:	df 93       	push	r29
 430:	d8 2f       	mov	r29, r24
 432:	c9 2f       	mov	r28, r25
   uint8_t i, j;

   printf(" A B C\r\n");
 434:	84 e3       	ldi	r24, 0x34	; 52
 436:	92 e0       	ldi	r25, 0x02	; 2
 438:	0e 94 93 04 	call	0x926	; 0x926 <puts>
 43c:	ed 2e       	mov	r14, r29
 43e:	fc 2e       	mov	r15, r28
 440:	cc 24       	eor	r12, r12
 442:	c3 94       	inc	r12
 444:	d1 2c       	mov	r13, r1

   for(i = 0; i < 3; i++) {
       printf("%d ", i + 1);
 446:	0f 2e       	mov	r0, r31
 448:	fc e3       	ldi	r31, 0x3C	; 60
 44a:	af 2e       	mov	r10, r31
 44c:	f2 e0       	ldi	r31, 0x02	; 2
 44e:	bf 2e       	mov	r11, r31
 450:	f0 2d       	mov	r31, r0
       for(j = 0; j < 3; j++) {
           printf("%c ", board[i][j]);
 452:	00 e4       	ldi	r16, 0x40	; 64
 454:	12 e0       	ldi	r17, 0x02	; 2
   uint8_t i, j;

   printf(" A B C\r\n");

   for(i = 0; i < 3; i++) {
       printf("%d ", i + 1);
 456:	df 92       	push	r13
 458:	cf 92       	push	r12
 45a:	bf 92       	push	r11
 45c:	af 92       	push	r10
 45e:	0e 94 7d 04 	call	0x8fa	; 0x8fa <printf>
 462:	0f 90       	pop	r0
 464:	0f 90       	pop	r0
 466:	0f 90       	pop	r0
 468:	0f 90       	pop	r0
 46a:	c0 e0       	ldi	r28, 0x00	; 0
 46c:	d0 e0       	ldi	r29, 0x00	; 0
       for(j = 0; j < 3; j++) {
           printf("%c ", board[i][j]);
 46e:	d7 01       	movw	r26, r14
 470:	ed 91       	ld	r30, X+
 472:	fc 91       	ld	r31, X
 474:	ec 0f       	add	r30, r28
 476:	fd 1f       	adc	r31, r29
 478:	80 81       	ld	r24, Z
 47a:	1f 92       	push	r1
 47c:	8f 93       	push	r24
 47e:	1f 93       	push	r17
 480:	0f 93       	push	r16
 482:	0e 94 7d 04 	call	0x8fa	; 0x8fa <printf>
 486:	21 96       	adiw	r28, 0x01	; 1

   printf(" A B C\r\n");

   for(i = 0; i < 3; i++) {
       printf("%d ", i + 1);
       for(j = 0; j < 3; j++) {
 488:	0f 90       	pop	r0
 48a:	0f 90       	pop	r0
 48c:	0f 90       	pop	r0
 48e:	0f 90       	pop	r0
 490:	c3 30       	cpi	r28, 0x03	; 3
 492:	d1 05       	cpc	r29, r1
 494:	61 f7       	brne	.-40     	; 0x46e <display_board+0x52>
           printf("%c ", board[i][j]);
       }
       printf("\r\n");
 496:	81 e6       	ldi	r24, 0x61	; 97
 498:	91 e0       	ldi	r25, 0x01	; 1
 49a:	0e 94 93 04 	call	0x926	; 0x926 <puts>
 49e:	bf ef       	ldi	r27, 0xFF	; 255
 4a0:	cb 1a       	sub	r12, r27
 4a2:	db 0a       	sbc	r13, r27
 4a4:	82 e0       	ldi	r24, 0x02	; 2
 4a6:	e8 0e       	add	r14, r24
 4a8:	f1 1c       	adc	r15, r1
void display_board(char** board) {
   uint8_t i, j;

   printf(" A B C\r\n");

   for(i = 0; i < 3; i++) {
 4aa:	a4 e0       	ldi	r26, 0x04	; 4
 4ac:	ca 16       	cp	r12, r26
 4ae:	d1 04       	cpc	r13, r1
 4b0:	91 f6       	brne	.-92     	; 0x456 <display_board+0x3a>
       for(j = 0; j < 3; j++) {
           printf("%c ", board[i][j]);
       }
       printf("\r\n");
   } 
}
 4b2:	df 91       	pop	r29
 4b4:	cf 91       	pop	r28
 4b6:	1f 91       	pop	r17
 4b8:	0f 91       	pop	r16
 4ba:	ff 90       	pop	r15
 4bc:	ef 90       	pop	r14
 4be:	df 90       	pop	r13
 4c0:	cf 90       	pop	r12
 4c2:	bf 90       	pop	r11
 4c4:	af 90       	pop	r10
 4c6:	08 95       	ret

000004c8 <get_player_positions>:
/* Returns a digital 16 bit reading of the given player's positions on the board.
 * If the player has a tile in a given position, it is written as a 1.
 * The two position data bytes are represented as follows:
 * xxxxxxxC3B3A3C2B2A2C1B1A1
 */
uint16_t get_player_positions(char** board, char player) {
 4c8:	ef 92       	push	r14
 4ca:	ff 92       	push	r15
 4cc:	0f 93       	push	r16
 4ce:	1f 93       	push	r17
 4d0:	cf 93       	push	r28
 4d2:	df 93       	push	r29
    assert(player == 'x' || player == 'o');
 4d4:	68 37       	cpi	r22, 0x78	; 120
 4d6:	11 f0       	breq	.+4      	; 0x4dc <get_player_positions+0x14>
 4d8:	6f 36       	cpi	r22, 0x6F	; 111
 4da:	51 f4       	brne	.+20     	; 0x4f0 <get_player_positions+0x28>
 4dc:	c8 2f       	mov	r28, r24
 4de:	d9 2f       	mov	r29, r25
    uint8_t i, j;
    uint16_t position_data = 0;
    for(i = 0; i < 3; i++) {
        for(j = 0; j < 3; j++) {
            if(board[i][j] == player) {
 4e0:	a0 e0       	ldi	r26, 0x00	; 0
 4e2:	b0 e0       	ldi	r27, 0x00	; 0
 4e4:	00 e0       	ldi	r16, 0x00	; 0
 4e6:	10 e0       	ldi	r17, 0x00	; 0
                position_data |= (1 << (i * 3 + j)); // shifts in a 1 to the appropriate position
 4e8:	ee 24       	eor	r14, r14
 4ea:	e3 94       	inc	r14
 4ec:	f1 2c       	mov	r15, r1
 4ee:	17 c0       	rjmp	.+46     	; 0x51e <get_player_positions+0x56>
 * If the player has a tile in a given position, it is written as a 1.
 * The two position data bytes are represented as follows:
 * xxxxxxxC3B3A3C2B2A2C1B1A1
 */
uint16_t get_player_positions(char** board, char player) {
    assert(player == 'x' || player == 'o');
 4f0:	0e 94 78 04 	call	0x8f0	; 0x8f0 <abort>
    uint8_t i, j;
    uint16_t position_data = 0;
    for(i = 0; i < 3; i++) {
        for(j = 0; j < 3; j++) {
            if(board[i][j] == player) {
 4f4:	91 91       	ld	r25, Z+
 4f6:	69 13       	cpse	r22, r25
 4f8:	09 c0       	rjmp	.+18     	; 0x50c <get_player_positions+0x44>
                position_data |= (1 << (i * 3 + j)); // shifts in a 1 to the appropriate position
 4fa:	c7 01       	movw	r24, r14
 4fc:	02 2e       	mov	r0, r18
 4fe:	02 c0       	rjmp	.+4      	; 0x504 <get_player_positions+0x3c>
 500:	88 0f       	add	r24, r24
 502:	99 1f       	adc	r25, r25
 504:	0a 94       	dec	r0
 506:	e2 f7       	brpl	.-8      	; 0x500 <get_player_positions+0x38>
 508:	08 2b       	or	r16, r24
 50a:	19 2b       	or	r17, r25
 50c:	2f 5f       	subi	r18, 0xFF	; 255
 50e:	3f 4f       	sbci	r19, 0xFF	; 255
uint16_t get_player_positions(char** board, char player) {
    assert(player == 'x' || player == 'o');
    uint8_t i, j;
    uint16_t position_data = 0;
    for(i = 0; i < 3; i++) {
        for(j = 0; j < 3; j++) {
 510:	e4 17       	cp	r30, r20
 512:	f5 07       	cpc	r31, r21
 514:	79 f7       	brne	.-34     	; 0x4f4 <get_player_positions+0x2c>
 516:	13 96       	adiw	r26, 0x03	; 3
 */
uint16_t get_player_positions(char** board, char player) {
    assert(player == 'x' || player == 'o');
    uint8_t i, j;
    uint16_t position_data = 0;
    for(i = 0; i < 3; i++) {
 518:	a9 30       	cpi	r26, 0x09	; 9
 51a:	b1 05       	cpc	r27, r1
 51c:	39 f0       	breq	.+14     	; 0x52c <get_player_positions+0x64>
        for(j = 0; j < 3; j++) {
            if(board[i][j] == player) {
 51e:	49 91       	ld	r20, Y+
 520:	59 91       	ld	r21, Y+
 522:	fa 01       	movw	r30, r20
 524:	4d 5f       	subi	r20, 0xFD	; 253
 526:	5f 4f       	sbci	r21, 0xFF	; 255
 528:	9d 01       	movw	r18, r26
 52a:	e4 cf       	rjmp	.-56     	; 0x4f4 <get_player_positions+0x2c>
            }
        }
    }

    return position_data;
}
 52c:	c8 01       	movw	r24, r16
 52e:	df 91       	pop	r29
 530:	cf 91       	pop	r28
 532:	1f 91       	pop	r17
 534:	0f 91       	pop	r16
 536:	ff 90       	pop	r15
 538:	ef 90       	pop	r14
 53a:	08 95       	ret

0000053c <find_changed_bit>:
 * Case 3: More than one bit flips from a 0 to a 1
 * Case 4: One or more bits flip from a 1 to a 0
 * 
 * Returns 0x0A if inputs are equal, 0x0B if more than one bit flips, 0x0C if a bit goes from 1 to 0, pos of changed bit otherwise
 */
uint8_t find_changed_bit(uint16_t old_input, uint16_t new_input) {
 53c:	af 92       	push	r10
 53e:	bf 92       	push	r11
 540:	cf 92       	push	r12
 542:	df 92       	push	r13
 544:	ef 92       	push	r14
 546:	ff 92       	push	r15
 548:	0f 93       	push	r16
 54a:	1f 93       	push	r17
 54c:	cf 93       	push	r28
 54e:	df 93       	push	r29
 550:	8c 01       	movw	r16, r24
 552:	7b 01       	movw	r14, r22
    // case 1
    if(old_input == new_input) {
 554:	86 17       	cp	r24, r22
 556:	97 07       	cpc	r25, r23
 558:	a9 f1       	breq	.+106    	; 0x5c4 <find_changed_bit+0x88>
 55a:	c0 e0       	ldi	r28, 0x00	; 0
 55c:	d0 e0       	ldi	r29, 0x00	; 0
 55e:	73 e0       	ldi	r23, 0x03	; 3
 560:	80 e0       	ldi	r24, 0x00	; 0
 562:	a1 2c       	mov	r10, r1
 564:	b1 2c       	mov	r11, r1
    uint16_t bit_mask = 0, changed = 0, old_bit = 0, new_bit = 0;
    uint8_t i, j, pos, flag = 0;
    for(i = 0; i < 3; i++) {
        for(j = 0; j < 3; j++) {
            pos = i * 3 + j;
            bit_mask = (1 << (i * 3 + j));
 566:	cc 24       	eor	r12, r12
 568:	c3 94       	inc	r12
 56a:	d1 2c       	mov	r13, r1
            if(!(new_bit - bit_mask)) {

                if(old_bit - bit_mask) {
                        // case 2 or 3
                        if(!flag) {
                            flag = 1;
 56c:	61 e0       	ldi	r22, 0x01	; 1
 56e:	25 c0       	rjmp	.+74     	; 0x5ba <find_changed_bit+0x7e>
    uint16_t bit_mask = 0, changed = 0, old_bit = 0, new_bit = 0;
    uint8_t i, j, pos, flag = 0;
    for(i = 0; i < 3; i++) {
        for(j = 0; j < 3; j++) {
            pos = i * 3 + j;
            bit_mask = (1 << (i * 3 + j));
 570:	96 01       	movw	r18, r12
 572:	04 2e       	mov	r0, r20
 574:	02 c0       	rjmp	.+4      	; 0x57a <find_changed_bit+0x3e>
 576:	22 0f       	add	r18, r18
 578:	33 1f       	adc	r19, r19
 57a:	0a 94       	dec	r0
 57c:	e2 f7       	brpl	.-8      	; 0x576 <find_changed_bit+0x3a>
            old_bit = old_input & bit_mask;
 57e:	f8 01       	movw	r30, r16
 580:	e2 23       	and	r30, r18
 582:	f3 23       	and	r31, r19
            new_bit = new_input & bit_mask;

            if(!(new_bit - bit_mask)) {
 584:	d7 01       	movw	r26, r14
 586:	a2 23       	and	r26, r18
 588:	b3 23       	and	r27, r19
 58a:	2a 17       	cp	r18, r26
 58c:	3b 07       	cpc	r19, r27
 58e:	41 f4       	brne	.+16     	; 0x5a0 <find_changed_bit+0x64>

                if(old_bit - bit_mask) {
 590:	2e 17       	cp	r18, r30
 592:	3f 07       	cpc	r19, r31
 594:	41 f0       	breq	.+16     	; 0x5a6 <find_changed_bit+0x6a>
                        // case 2 or 3
                        if(!flag) {
 596:	81 11       	cpse	r24, r1
 598:	17 c0       	rjmp	.+46     	; 0x5c8 <find_changed_bit+0x8c>
                            flag = 1;
                            changed = pos; 
 59a:	a9 2e       	mov	r10, r25
            if(!(new_bit - bit_mask)) {

                if(old_bit - bit_mask) {
                        // case 2 or 3
                        if(!flag) {
                            flag = 1;
 59c:	86 2f       	mov	r24, r22
 59e:	03 c0       	rjmp	.+6      	; 0x5a6 <find_changed_bit+0x6a>
                        }
                        else return 0x0B;
                }
            } else {
                
                if(!(old_bit - bit_mask)) {
 5a0:	2e 17       	cp	r18, r30
 5a2:	3f 07       	cpc	r19, r31
 5a4:	99 f0       	breq	.+38     	; 0x5cc <find_changed_bit+0x90>
 5a6:	4f 5f       	subi	r20, 0xFF	; 255
 5a8:	5f 4f       	sbci	r21, 0xFF	; 255
 5aa:	9f 5f       	subi	r25, 0xFF	; 255
    }

    uint16_t bit_mask = 0, changed = 0, old_bit = 0, new_bit = 0;
    uint8_t i, j, pos, flag = 0;
    for(i = 0; i < 3; i++) {
        for(j = 0; j < 3; j++) {
 5ac:	79 13       	cpse	r23, r25
 5ae:	e0 cf       	rjmp	.-64     	; 0x570 <find_changed_bit+0x34>
 5b0:	7d 5f       	subi	r23, 0xFD	; 253
 5b2:	23 96       	adiw	r28, 0x03	; 3
        return 0x0A;
    }

    uint16_t bit_mask = 0, changed = 0, old_bit = 0, new_bit = 0;
    uint8_t i, j, pos, flag = 0;
    for(i = 0; i < 3; i++) {
 5b4:	c9 30       	cpi	r28, 0x09	; 9
 5b6:	d1 05       	cpc	r29, r1
 5b8:	19 f0       	breq	.+6      	; 0x5c0 <find_changed_bit+0x84>
        for(j = 0; j < 3; j++) {
            pos = i * 3 + j;
 5ba:	9c 2f       	mov	r25, r28
 5bc:	ae 01       	movw	r20, r28
 5be:	d8 cf       	rjmp	.-80     	; 0x570 <find_changed_bit+0x34>
                }
            }
        }
    }

    return changed;
 5c0:	8a 2d       	mov	r24, r10
 5c2:	05 c0       	rjmp	.+10     	; 0x5ce <find_changed_bit+0x92>
 * Returns 0x0A if inputs are equal, 0x0B if more than one bit flips, 0x0C if a bit goes from 1 to 0, pos of changed bit otherwise
 */
uint8_t find_changed_bit(uint16_t old_input, uint16_t new_input) {
    // case 1
    if(old_input == new_input) {
        return 0x0A;
 5c4:	8a e0       	ldi	r24, 0x0A	; 10
 5c6:	03 c0       	rjmp	.+6      	; 0x5ce <find_changed_bit+0x92>
                        // case 2 or 3
                        if(!flag) {
                            flag = 1;
                            changed = pos; 
                        }
                        else return 0x0B;
 5c8:	8b e0       	ldi	r24, 0x0B	; 11
 5ca:	01 c0       	rjmp	.+2      	; 0x5ce <find_changed_bit+0x92>
                }
            } else {
                
                if(!(old_bit - bit_mask)) {
                    // case 4
                    return 0x0C;
 5cc:	8c e0       	ldi	r24, 0x0C	; 12
            }
        }
    }

    return changed;
}
 5ce:	df 91       	pop	r29
 5d0:	cf 91       	pop	r28
 5d2:	1f 91       	pop	r17
 5d4:	0f 91       	pop	r16
 5d6:	ff 90       	pop	r15
 5d8:	ef 90       	pop	r14
 5da:	df 90       	pop	r13
 5dc:	cf 90       	pop	r12
 5de:	bf 90       	pop	r11
 5e0:	af 90       	pop	r10
 5e2:	08 95       	ret

000005e4 <update_board>:


/* Places x or o on given board tile if valid */
void update_board(char** board, char player, char row, char col) {
    assert(row >= 0 && row < 3 && col >= 0 && col < 3);
 5e4:	43 30       	cpi	r20, 0x03	; 3
 5e6:	10 f4       	brcc	.+4      	; 0x5ec <update_board+0x8>
 5e8:	23 30       	cpi	r18, 0x03	; 3
 5ea:	10 f0       	brcs	.+4      	; 0x5f0 <update_board+0xc>
 5ec:	0e 94 78 04 	call	0x8f0	; 0x8f0 <abort>
    assert(player == 'x' || player == 'o');
 5f0:	68 37       	cpi	r22, 0x78	; 120
 5f2:	21 f0       	breq	.+8      	; 0x5fc <update_board+0x18>
 5f4:	6f 36       	cpi	r22, 0x6F	; 111
 5f6:	11 f0       	breq	.+4      	; 0x5fc <update_board+0x18>
 5f8:	0e 94 78 04 	call	0x8f0	; 0x8f0 <abort>
    board[row][col] = player;
 5fc:	50 e0       	ldi	r21, 0x00	; 0
 5fe:	44 0f       	add	r20, r20
 600:	55 1f       	adc	r21, r21
 602:	fc 01       	movw	r30, r24
 604:	e4 0f       	add	r30, r20
 606:	f5 1f       	adc	r31, r21
 608:	01 90       	ld	r0, Z+
 60a:	f0 81       	ld	r31, Z
 60c:	e0 2d       	mov	r30, r0
 60e:	e2 0f       	add	r30, r18
 610:	f1 1d       	adc	r31, r1
 612:	60 83       	st	Z, r22
 614:	08 95       	ret

00000616 <check_victory>:

/* Checks if a given player has won the game, using bit masks.
 * If the player has won, returns the specific 16 bit victory condition that the player achieved.
 * Otherwise, returns 0
 */
uint16_t check_victory(char** board, char player) {
 616:	cf 93       	push	r28
 618:	df 93       	push	r29
 61a:	cd b7       	in	r28, 0x3d	; 61
 61c:	de b7       	in	r29, 0x3e	; 62
 61e:	60 97       	sbiw	r28, 0x10	; 16
 620:	0f b6       	in	r0, 0x3f	; 63
 622:	f8 94       	cli
 624:	de bf       	out	0x3e, r29	; 62
 626:	0f be       	out	0x3f, r0	; 63
 628:	cd bf       	out	0x3d, r28	; 61
    
   // get_player_positions will return 2 bytes in format of xxxxxxxC3B3A3C2B2A2C1B1A1
   // The following combinations will win the game if all 1's are from the same player:
   // 111xxxxxx, xxx111xxx, xxxxxx111, 1xx1xx1xx, x1xx1xx1x, xx1xx1xx1, xx1x1x1xx, 1xxx1xxx1

    const uint16_t conditions[8] = {0b0000000111000000, 0b0000000000111000, 0b0000000000000111, 0b0000000100100100,
 62a:	20 e1       	ldi	r18, 0x10	; 16
 62c:	e4 e1       	ldi	r30, 0x14	; 20
 62e:	f1 e0       	ldi	r31, 0x01	; 1
 630:	de 01       	movw	r26, r28
 632:	11 96       	adiw	r26, 0x01	; 1
 634:	01 90       	ld	r0, Z+
 636:	0d 92       	st	X+, r0
 638:	2a 95       	dec	r18
 63a:	e1 f7       	brne	.-8      	; 0x634 <check_victory+0x1e>
                           0b0000000010010010, 0b0000000001001001, 0b0000000001010100, 0b0000000100010001};

    uint16_t positions = get_player_positions(board, player);
 63c:	0e 94 64 02 	call	0x4c8	; 0x4c8 <get_player_positions>
 640:	ac 01       	movw	r20, r24
    uint8_t i;

    for(i = 0; i < 8; i++) {
        if(!((positions & conditions[i]) - conditions[i])) {
 642:	29 81       	ldd	r18, Y+1	; 0x01
 644:	3a 81       	ldd	r19, Y+2	; 0x02
 646:	82 23       	and	r24, r18
 648:	93 23       	and	r25, r19
 64a:	28 17       	cp	r18, r24
 64c:	39 07       	cpc	r19, r25
 64e:	91 f0       	breq	.+36     	; 0x674 <check_victory+0x5e>
 650:	fe 01       	movw	r30, r28
 652:	33 96       	adiw	r30, 0x03	; 3
 654:	be 01       	movw	r22, r28
 656:	6f 5e       	subi	r22, 0xEF	; 239
 658:	7f 4f       	sbci	r23, 0xFF	; 255
 65a:	21 91       	ld	r18, Z+
 65c:	31 91       	ld	r19, Z+
 65e:	ca 01       	movw	r24, r20
 660:	82 23       	and	r24, r18
 662:	93 23       	and	r25, r19
 664:	28 17       	cp	r18, r24
 666:	39 07       	cpc	r19, r25
 668:	29 f0       	breq	.+10     	; 0x674 <check_victory+0x5e>
                           0b0000000010010010, 0b0000000001001001, 0b0000000001010100, 0b0000000100010001};

    uint16_t positions = get_player_positions(board, player);
    uint8_t i;

    for(i = 0; i < 8; i++) {
 66a:	e6 17       	cp	r30, r22
 66c:	f7 07       	cpc	r31, r23
 66e:	a9 f7       	brne	.-22     	; 0x65a <check_victory+0x44>
        if(!((positions & conditions[i]) - conditions[i])) {
            return conditions[i];
        }
    }

   return 0;
 670:	80 e0       	ldi	r24, 0x00	; 0
 672:	90 e0       	ldi	r25, 0x00	; 0
 674:	60 96       	adiw	r28, 0x10	; 16
 676:	0f b6       	in	r0, 0x3f	; 63
 678:	f8 94       	cli
 67a:	de bf       	out	0x3e, r29	; 62
 67c:	0f be       	out	0x3f, r0	; 63
 67e:	cd bf       	out	0x3d, r28	; 61
 680:	df 91       	pop	r29
 682:	cf 91       	pop	r28
 684:	08 95       	ret

00000686 <USART_init>:
#define F_CPU 16000000UL
#define BAUD 9600
#define BRC ( (F_CPU / 16 / BAUD) - 1)

void USART_init() {
	UBRR0H = (BRC >> 8);
 686:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
	UBRR0L = BRC; // load baud rate
 68a:	87 e6       	ldi	r24, 0x67	; 103
 68c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
	
	UCSR0B = (1 << TXEN0); // enable transmitter
 690:	88 e0       	ldi	r24, 0x08	; 8
 692:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
	UCSR0C = (1 << UCSZ00) | (1 << UCSZ01); // set number of bits per frame to 8 (1 char)
 696:	86 e0       	ldi	r24, 0x06	; 6
 698:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
 69c:	08 95       	ret

0000069e <USART_putchar>:
	
}

void USART_putchar(unsigned char c) {
	// Note: code taken from datasheet of atmega328p
	while(!(UCSR0A & (1 << UDRE0))); // poll, wait for empty transmit buffer
 69e:	e0 ec       	ldi	r30, 0xC0	; 192
 6a0:	f0 e0       	ldi	r31, 0x00	; 0
 6a2:	90 81       	ld	r25, Z
 6a4:	95 ff       	sbrs	r25, 5
 6a6:	fd cf       	rjmp	.-6      	; 0x6a2 <USART_putchar+0x4>
	
	// once data is placed in UDR0, it transmits automatically
	UDR0 = c;
 6a8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 6ac:	08 95       	ret

000006ae <malloc>:
 6ae:	0f 93       	push	r16
 6b0:	1f 93       	push	r17
 6b2:	cf 93       	push	r28
 6b4:	df 93       	push	r29
 6b6:	82 30       	cpi	r24, 0x02	; 2
 6b8:	91 05       	cpc	r25, r1
 6ba:	10 f4       	brcc	.+4      	; 0x6c0 <malloc+0x12>
 6bc:	82 e0       	ldi	r24, 0x02	; 2
 6be:	90 e0       	ldi	r25, 0x00	; 0
 6c0:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <__flp>
 6c4:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <__flp+0x1>
 6c8:	20 e0       	ldi	r18, 0x00	; 0
 6ca:	30 e0       	ldi	r19, 0x00	; 0
 6cc:	a0 e0       	ldi	r26, 0x00	; 0
 6ce:	b0 e0       	ldi	r27, 0x00	; 0
 6d0:	30 97       	sbiw	r30, 0x00	; 0
 6d2:	19 f1       	breq	.+70     	; 0x71a <malloc+0x6c>
 6d4:	40 81       	ld	r20, Z
 6d6:	51 81       	ldd	r21, Z+1	; 0x01
 6d8:	02 81       	ldd	r16, Z+2	; 0x02
 6da:	13 81       	ldd	r17, Z+3	; 0x03
 6dc:	48 17       	cp	r20, r24
 6de:	59 07       	cpc	r21, r25
 6e0:	c8 f0       	brcs	.+50     	; 0x714 <malloc+0x66>
 6e2:	84 17       	cp	r24, r20
 6e4:	95 07       	cpc	r25, r21
 6e6:	69 f4       	brne	.+26     	; 0x702 <malloc+0x54>
 6e8:	10 97       	sbiw	r26, 0x00	; 0
 6ea:	31 f0       	breq	.+12     	; 0x6f8 <malloc+0x4a>
 6ec:	12 96       	adiw	r26, 0x02	; 2
 6ee:	0c 93       	st	X, r16
 6f0:	12 97       	sbiw	r26, 0x02	; 2
 6f2:	13 96       	adiw	r26, 0x03	; 3
 6f4:	1c 93       	st	X, r17
 6f6:	27 c0       	rjmp	.+78     	; 0x746 <malloc+0x98>
 6f8:	00 93 46 02 	sts	0x0246, r16	; 0x800246 <__flp>
 6fc:	10 93 47 02 	sts	0x0247, r17	; 0x800247 <__flp+0x1>
 700:	22 c0       	rjmp	.+68     	; 0x746 <malloc+0x98>
 702:	21 15       	cp	r18, r1
 704:	31 05       	cpc	r19, r1
 706:	19 f0       	breq	.+6      	; 0x70e <malloc+0x60>
 708:	42 17       	cp	r20, r18
 70a:	53 07       	cpc	r21, r19
 70c:	18 f4       	brcc	.+6      	; 0x714 <malloc+0x66>
 70e:	9a 01       	movw	r18, r20
 710:	bd 01       	movw	r22, r26
 712:	ef 01       	movw	r28, r30
 714:	df 01       	movw	r26, r30
 716:	f8 01       	movw	r30, r16
 718:	db cf       	rjmp	.-74     	; 0x6d0 <malloc+0x22>
 71a:	21 15       	cp	r18, r1
 71c:	31 05       	cpc	r19, r1
 71e:	f9 f0       	breq	.+62     	; 0x75e <malloc+0xb0>
 720:	28 1b       	sub	r18, r24
 722:	39 0b       	sbc	r19, r25
 724:	24 30       	cpi	r18, 0x04	; 4
 726:	31 05       	cpc	r19, r1
 728:	80 f4       	brcc	.+32     	; 0x74a <malloc+0x9c>
 72a:	8a 81       	ldd	r24, Y+2	; 0x02
 72c:	9b 81       	ldd	r25, Y+3	; 0x03
 72e:	61 15       	cp	r22, r1
 730:	71 05       	cpc	r23, r1
 732:	21 f0       	breq	.+8      	; 0x73c <malloc+0x8e>
 734:	fb 01       	movw	r30, r22
 736:	93 83       	std	Z+3, r25	; 0x03
 738:	82 83       	std	Z+2, r24	; 0x02
 73a:	04 c0       	rjmp	.+8      	; 0x744 <malloc+0x96>
 73c:	90 93 47 02 	sts	0x0247, r25	; 0x800247 <__flp+0x1>
 740:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <__flp>
 744:	fe 01       	movw	r30, r28
 746:	32 96       	adiw	r30, 0x02	; 2
 748:	44 c0       	rjmp	.+136    	; 0x7d2 <malloc+0x124>
 74a:	fe 01       	movw	r30, r28
 74c:	e2 0f       	add	r30, r18
 74e:	f3 1f       	adc	r31, r19
 750:	81 93       	st	Z+, r24
 752:	91 93       	st	Z+, r25
 754:	22 50       	subi	r18, 0x02	; 2
 756:	31 09       	sbc	r19, r1
 758:	39 83       	std	Y+1, r19	; 0x01
 75a:	28 83       	st	Y, r18
 75c:	3a c0       	rjmp	.+116    	; 0x7d2 <malloc+0x124>
 75e:	20 91 44 02 	lds	r18, 0x0244	; 0x800244 <__data_end>
 762:	30 91 45 02 	lds	r19, 0x0245	; 0x800245 <__data_end+0x1>
 766:	23 2b       	or	r18, r19
 768:	41 f4       	brne	.+16     	; 0x77a <malloc+0xcc>
 76a:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
 76e:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
 772:	30 93 45 02 	sts	0x0245, r19	; 0x800245 <__data_end+0x1>
 776:	20 93 44 02 	sts	0x0244, r18	; 0x800244 <__data_end>
 77a:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
 77e:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
 782:	21 15       	cp	r18, r1
 784:	31 05       	cpc	r19, r1
 786:	41 f4       	brne	.+16     	; 0x798 <malloc+0xea>
 788:	2d b7       	in	r18, 0x3d	; 61
 78a:	3e b7       	in	r19, 0x3e	; 62
 78c:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
 790:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
 794:	24 1b       	sub	r18, r20
 796:	35 0b       	sbc	r19, r21
 798:	e0 91 44 02 	lds	r30, 0x0244	; 0x800244 <__data_end>
 79c:	f0 91 45 02 	lds	r31, 0x0245	; 0x800245 <__data_end+0x1>
 7a0:	e2 17       	cp	r30, r18
 7a2:	f3 07       	cpc	r31, r19
 7a4:	a0 f4       	brcc	.+40     	; 0x7ce <malloc+0x120>
 7a6:	2e 1b       	sub	r18, r30
 7a8:	3f 0b       	sbc	r19, r31
 7aa:	28 17       	cp	r18, r24
 7ac:	39 07       	cpc	r19, r25
 7ae:	78 f0       	brcs	.+30     	; 0x7ce <malloc+0x120>
 7b0:	ac 01       	movw	r20, r24
 7b2:	4e 5f       	subi	r20, 0xFE	; 254
 7b4:	5f 4f       	sbci	r21, 0xFF	; 255
 7b6:	24 17       	cp	r18, r20
 7b8:	35 07       	cpc	r19, r21
 7ba:	48 f0       	brcs	.+18     	; 0x7ce <malloc+0x120>
 7bc:	4e 0f       	add	r20, r30
 7be:	5f 1f       	adc	r21, r31
 7c0:	50 93 45 02 	sts	0x0245, r21	; 0x800245 <__data_end+0x1>
 7c4:	40 93 44 02 	sts	0x0244, r20	; 0x800244 <__data_end>
 7c8:	81 93       	st	Z+, r24
 7ca:	91 93       	st	Z+, r25
 7cc:	02 c0       	rjmp	.+4      	; 0x7d2 <malloc+0x124>
 7ce:	e0 e0       	ldi	r30, 0x00	; 0
 7d0:	f0 e0       	ldi	r31, 0x00	; 0
 7d2:	cf 01       	movw	r24, r30
 7d4:	df 91       	pop	r29
 7d6:	cf 91       	pop	r28
 7d8:	1f 91       	pop	r17
 7da:	0f 91       	pop	r16
 7dc:	08 95       	ret

000007de <free>:
 7de:	cf 93       	push	r28
 7e0:	df 93       	push	r29
 7e2:	00 97       	sbiw	r24, 0x00	; 0
 7e4:	09 f4       	brne	.+2      	; 0x7e8 <free+0xa>
 7e6:	81 c0       	rjmp	.+258    	; 0x8ea <free+0x10c>
 7e8:	fc 01       	movw	r30, r24
 7ea:	32 97       	sbiw	r30, 0x02	; 2
 7ec:	13 82       	std	Z+3, r1	; 0x03
 7ee:	12 82       	std	Z+2, r1	; 0x02
 7f0:	a0 91 46 02 	lds	r26, 0x0246	; 0x800246 <__flp>
 7f4:	b0 91 47 02 	lds	r27, 0x0247	; 0x800247 <__flp+0x1>
 7f8:	10 97       	sbiw	r26, 0x00	; 0
 7fa:	81 f4       	brne	.+32     	; 0x81c <free+0x3e>
 7fc:	20 81       	ld	r18, Z
 7fe:	31 81       	ldd	r19, Z+1	; 0x01
 800:	82 0f       	add	r24, r18
 802:	93 1f       	adc	r25, r19
 804:	20 91 44 02 	lds	r18, 0x0244	; 0x800244 <__data_end>
 808:	30 91 45 02 	lds	r19, 0x0245	; 0x800245 <__data_end+0x1>
 80c:	28 17       	cp	r18, r24
 80e:	39 07       	cpc	r19, r25
 810:	51 f5       	brne	.+84     	; 0x866 <free+0x88>
 812:	f0 93 45 02 	sts	0x0245, r31	; 0x800245 <__data_end+0x1>
 816:	e0 93 44 02 	sts	0x0244, r30	; 0x800244 <__data_end>
 81a:	67 c0       	rjmp	.+206    	; 0x8ea <free+0x10c>
 81c:	ed 01       	movw	r28, r26
 81e:	20 e0       	ldi	r18, 0x00	; 0
 820:	30 e0       	ldi	r19, 0x00	; 0
 822:	ce 17       	cp	r28, r30
 824:	df 07       	cpc	r29, r31
 826:	40 f4       	brcc	.+16     	; 0x838 <free+0x5a>
 828:	4a 81       	ldd	r20, Y+2	; 0x02
 82a:	5b 81       	ldd	r21, Y+3	; 0x03
 82c:	9e 01       	movw	r18, r28
 82e:	41 15       	cp	r20, r1
 830:	51 05       	cpc	r21, r1
 832:	f1 f0       	breq	.+60     	; 0x870 <free+0x92>
 834:	ea 01       	movw	r28, r20
 836:	f5 cf       	rjmp	.-22     	; 0x822 <free+0x44>
 838:	d3 83       	std	Z+3, r29	; 0x03
 83a:	c2 83       	std	Z+2, r28	; 0x02
 83c:	40 81       	ld	r20, Z
 83e:	51 81       	ldd	r21, Z+1	; 0x01
 840:	84 0f       	add	r24, r20
 842:	95 1f       	adc	r25, r21
 844:	c8 17       	cp	r28, r24
 846:	d9 07       	cpc	r29, r25
 848:	59 f4       	brne	.+22     	; 0x860 <free+0x82>
 84a:	88 81       	ld	r24, Y
 84c:	99 81       	ldd	r25, Y+1	; 0x01
 84e:	84 0f       	add	r24, r20
 850:	95 1f       	adc	r25, r21
 852:	02 96       	adiw	r24, 0x02	; 2
 854:	91 83       	std	Z+1, r25	; 0x01
 856:	80 83       	st	Z, r24
 858:	8a 81       	ldd	r24, Y+2	; 0x02
 85a:	9b 81       	ldd	r25, Y+3	; 0x03
 85c:	93 83       	std	Z+3, r25	; 0x03
 85e:	82 83       	std	Z+2, r24	; 0x02
 860:	21 15       	cp	r18, r1
 862:	31 05       	cpc	r19, r1
 864:	29 f4       	brne	.+10     	; 0x870 <free+0x92>
 866:	f0 93 47 02 	sts	0x0247, r31	; 0x800247 <__flp+0x1>
 86a:	e0 93 46 02 	sts	0x0246, r30	; 0x800246 <__flp>
 86e:	3d c0       	rjmp	.+122    	; 0x8ea <free+0x10c>
 870:	e9 01       	movw	r28, r18
 872:	fb 83       	std	Y+3, r31	; 0x03
 874:	ea 83       	std	Y+2, r30	; 0x02
 876:	49 91       	ld	r20, Y+
 878:	59 91       	ld	r21, Y+
 87a:	c4 0f       	add	r28, r20
 87c:	d5 1f       	adc	r29, r21
 87e:	ec 17       	cp	r30, r28
 880:	fd 07       	cpc	r31, r29
 882:	61 f4       	brne	.+24     	; 0x89c <free+0xbe>
 884:	80 81       	ld	r24, Z
 886:	91 81       	ldd	r25, Z+1	; 0x01
 888:	84 0f       	add	r24, r20
 88a:	95 1f       	adc	r25, r21
 88c:	02 96       	adiw	r24, 0x02	; 2
 88e:	e9 01       	movw	r28, r18
 890:	99 83       	std	Y+1, r25	; 0x01
 892:	88 83       	st	Y, r24
 894:	82 81       	ldd	r24, Z+2	; 0x02
 896:	93 81       	ldd	r25, Z+3	; 0x03
 898:	9b 83       	std	Y+3, r25	; 0x03
 89a:	8a 83       	std	Y+2, r24	; 0x02
 89c:	e0 e0       	ldi	r30, 0x00	; 0
 89e:	f0 e0       	ldi	r31, 0x00	; 0
 8a0:	12 96       	adiw	r26, 0x02	; 2
 8a2:	8d 91       	ld	r24, X+
 8a4:	9c 91       	ld	r25, X
 8a6:	13 97       	sbiw	r26, 0x03	; 3
 8a8:	00 97       	sbiw	r24, 0x00	; 0
 8aa:	19 f0       	breq	.+6      	; 0x8b2 <free+0xd4>
 8ac:	fd 01       	movw	r30, r26
 8ae:	dc 01       	movw	r26, r24
 8b0:	f7 cf       	rjmp	.-18     	; 0x8a0 <free+0xc2>
 8b2:	8d 91       	ld	r24, X+
 8b4:	9c 91       	ld	r25, X
 8b6:	11 97       	sbiw	r26, 0x01	; 1
 8b8:	9d 01       	movw	r18, r26
 8ba:	2e 5f       	subi	r18, 0xFE	; 254
 8bc:	3f 4f       	sbci	r19, 0xFF	; 255
 8be:	82 0f       	add	r24, r18
 8c0:	93 1f       	adc	r25, r19
 8c2:	20 91 44 02 	lds	r18, 0x0244	; 0x800244 <__data_end>
 8c6:	30 91 45 02 	lds	r19, 0x0245	; 0x800245 <__data_end+0x1>
 8ca:	28 17       	cp	r18, r24
 8cc:	39 07       	cpc	r19, r25
 8ce:	69 f4       	brne	.+26     	; 0x8ea <free+0x10c>
 8d0:	30 97       	sbiw	r30, 0x00	; 0
 8d2:	29 f4       	brne	.+10     	; 0x8de <free+0x100>
 8d4:	10 92 47 02 	sts	0x0247, r1	; 0x800247 <__flp+0x1>
 8d8:	10 92 46 02 	sts	0x0246, r1	; 0x800246 <__flp>
 8dc:	02 c0       	rjmp	.+4      	; 0x8e2 <free+0x104>
 8de:	13 82       	std	Z+3, r1	; 0x03
 8e0:	12 82       	std	Z+2, r1	; 0x02
 8e2:	b0 93 45 02 	sts	0x0245, r27	; 0x800245 <__data_end+0x1>
 8e6:	a0 93 44 02 	sts	0x0244, r26	; 0x800244 <__data_end>
 8ea:	df 91       	pop	r29
 8ec:	cf 91       	pop	r28
 8ee:	08 95       	ret

000008f0 <abort>:
 8f0:	81 e0       	ldi	r24, 0x01	; 1
 8f2:	90 e0       	ldi	r25, 0x00	; 0
 8f4:	f8 94       	cli
 8f6:	0c 94 8b 07 	jmp	0xf16	; 0xf16 <_exit>

000008fa <printf>:
 8fa:	a0 e0       	ldi	r26, 0x00	; 0
 8fc:	b0 e0       	ldi	r27, 0x00	; 0
 8fe:	e3 e8       	ldi	r30, 0x83	; 131
 900:	f4 e0       	ldi	r31, 0x04	; 4
 902:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__prologue_saves__+0x20>
 906:	ae 01       	movw	r20, r28
 908:	4b 5f       	subi	r20, 0xFB	; 251
 90a:	5f 4f       	sbci	r21, 0xFF	; 255
 90c:	fa 01       	movw	r30, r20
 90e:	61 91       	ld	r22, Z+
 910:	71 91       	ld	r23, Z+
 912:	af 01       	movw	r20, r30
 914:	80 91 4a 02 	lds	r24, 0x024A	; 0x80024a <__iob+0x2>
 918:	90 91 4b 02 	lds	r25, 0x024B	; 0x80024b <__iob+0x3>
 91c:	0e 94 c3 04 	call	0x986	; 0x986 <vfprintf>
 920:	e2 e0       	ldi	r30, 0x02	; 2
 922:	0c 94 80 07 	jmp	0xf00	; 0xf00 <__epilogue_restores__+0x20>

00000926 <puts>:
 926:	0f 93       	push	r16
 928:	1f 93       	push	r17
 92a:	cf 93       	push	r28
 92c:	df 93       	push	r29
 92e:	e0 91 4a 02 	lds	r30, 0x024A	; 0x80024a <__iob+0x2>
 932:	f0 91 4b 02 	lds	r31, 0x024B	; 0x80024b <__iob+0x3>
 936:	23 81       	ldd	r18, Z+3	; 0x03
 938:	21 ff       	sbrs	r18, 1
 93a:	1b c0       	rjmp	.+54     	; 0x972 <puts+0x4c>
 93c:	8c 01       	movw	r16, r24
 93e:	d0 e0       	ldi	r29, 0x00	; 0
 940:	c0 e0       	ldi	r28, 0x00	; 0
 942:	f8 01       	movw	r30, r16
 944:	81 91       	ld	r24, Z+
 946:	8f 01       	movw	r16, r30
 948:	60 91 4a 02 	lds	r22, 0x024A	; 0x80024a <__iob+0x2>
 94c:	70 91 4b 02 	lds	r23, 0x024B	; 0x80024b <__iob+0x3>
 950:	db 01       	movw	r26, r22
 952:	18 96       	adiw	r26, 0x08	; 8
 954:	ed 91       	ld	r30, X+
 956:	fc 91       	ld	r31, X
 958:	19 97       	sbiw	r26, 0x09	; 9
 95a:	88 23       	and	r24, r24
 95c:	31 f0       	breq	.+12     	; 0x96a <puts+0x44>
 95e:	09 95       	icall
 960:	89 2b       	or	r24, r25
 962:	79 f3       	breq	.-34     	; 0x942 <puts+0x1c>
 964:	df ef       	ldi	r29, 0xFF	; 255
 966:	cf ef       	ldi	r28, 0xFF	; 255
 968:	ec cf       	rjmp	.-40     	; 0x942 <puts+0x1c>
 96a:	8a e0       	ldi	r24, 0x0A	; 10
 96c:	09 95       	icall
 96e:	89 2b       	or	r24, r25
 970:	19 f0       	breq	.+6      	; 0x978 <puts+0x52>
 972:	8f ef       	ldi	r24, 0xFF	; 255
 974:	9f ef       	ldi	r25, 0xFF	; 255
 976:	02 c0       	rjmp	.+4      	; 0x97c <puts+0x56>
 978:	8d 2f       	mov	r24, r29
 97a:	9c 2f       	mov	r25, r28
 97c:	df 91       	pop	r29
 97e:	cf 91       	pop	r28
 980:	1f 91       	pop	r17
 982:	0f 91       	pop	r16
 984:	08 95       	ret

00000986 <vfprintf>:
 986:	ab e0       	ldi	r26, 0x0B	; 11
 988:	b0 e0       	ldi	r27, 0x00	; 0
 98a:	e9 ec       	ldi	r30, 0xC9	; 201
 98c:	f4 e0       	ldi	r31, 0x04	; 4
 98e:	0c 94 54 07 	jmp	0xea8	; 0xea8 <__prologue_saves__>
 992:	6c 01       	movw	r12, r24
 994:	7b 01       	movw	r14, r22
 996:	8a 01       	movw	r16, r20
 998:	fc 01       	movw	r30, r24
 99a:	17 82       	std	Z+7, r1	; 0x07
 99c:	16 82       	std	Z+6, r1	; 0x06
 99e:	83 81       	ldd	r24, Z+3	; 0x03
 9a0:	81 ff       	sbrs	r24, 1
 9a2:	cc c1       	rjmp	.+920    	; 0xd3c <vfprintf+0x3b6>
 9a4:	ce 01       	movw	r24, r28
 9a6:	01 96       	adiw	r24, 0x01	; 1
 9a8:	3c 01       	movw	r6, r24
 9aa:	f6 01       	movw	r30, r12
 9ac:	93 81       	ldd	r25, Z+3	; 0x03
 9ae:	f7 01       	movw	r30, r14
 9b0:	93 fd       	sbrc	r25, 3
 9b2:	85 91       	lpm	r24, Z+
 9b4:	93 ff       	sbrs	r25, 3
 9b6:	81 91       	ld	r24, Z+
 9b8:	7f 01       	movw	r14, r30
 9ba:	88 23       	and	r24, r24
 9bc:	09 f4       	brne	.+2      	; 0x9c0 <vfprintf+0x3a>
 9be:	ba c1       	rjmp	.+884    	; 0xd34 <vfprintf+0x3ae>
 9c0:	85 32       	cpi	r24, 0x25	; 37
 9c2:	39 f4       	brne	.+14     	; 0x9d2 <vfprintf+0x4c>
 9c4:	93 fd       	sbrc	r25, 3
 9c6:	85 91       	lpm	r24, Z+
 9c8:	93 ff       	sbrs	r25, 3
 9ca:	81 91       	ld	r24, Z+
 9cc:	7f 01       	movw	r14, r30
 9ce:	85 32       	cpi	r24, 0x25	; 37
 9d0:	29 f4       	brne	.+10     	; 0x9dc <vfprintf+0x56>
 9d2:	b6 01       	movw	r22, r12
 9d4:	90 e0       	ldi	r25, 0x00	; 0
 9d6:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 9da:	e7 cf       	rjmp	.-50     	; 0x9aa <vfprintf+0x24>
 9dc:	91 2c       	mov	r9, r1
 9de:	21 2c       	mov	r2, r1
 9e0:	31 2c       	mov	r3, r1
 9e2:	ff e1       	ldi	r31, 0x1F	; 31
 9e4:	f3 15       	cp	r31, r3
 9e6:	d8 f0       	brcs	.+54     	; 0xa1e <vfprintf+0x98>
 9e8:	8b 32       	cpi	r24, 0x2B	; 43
 9ea:	79 f0       	breq	.+30     	; 0xa0a <vfprintf+0x84>
 9ec:	38 f4       	brcc	.+14     	; 0x9fc <vfprintf+0x76>
 9ee:	80 32       	cpi	r24, 0x20	; 32
 9f0:	79 f0       	breq	.+30     	; 0xa10 <vfprintf+0x8a>
 9f2:	83 32       	cpi	r24, 0x23	; 35
 9f4:	a1 f4       	brne	.+40     	; 0xa1e <vfprintf+0x98>
 9f6:	23 2d       	mov	r18, r3
 9f8:	20 61       	ori	r18, 0x10	; 16
 9fa:	1d c0       	rjmp	.+58     	; 0xa36 <vfprintf+0xb0>
 9fc:	8d 32       	cpi	r24, 0x2D	; 45
 9fe:	61 f0       	breq	.+24     	; 0xa18 <vfprintf+0x92>
 a00:	80 33       	cpi	r24, 0x30	; 48
 a02:	69 f4       	brne	.+26     	; 0xa1e <vfprintf+0x98>
 a04:	23 2d       	mov	r18, r3
 a06:	21 60       	ori	r18, 0x01	; 1
 a08:	16 c0       	rjmp	.+44     	; 0xa36 <vfprintf+0xb0>
 a0a:	83 2d       	mov	r24, r3
 a0c:	82 60       	ori	r24, 0x02	; 2
 a0e:	38 2e       	mov	r3, r24
 a10:	e3 2d       	mov	r30, r3
 a12:	e4 60       	ori	r30, 0x04	; 4
 a14:	3e 2e       	mov	r3, r30
 a16:	2a c0       	rjmp	.+84     	; 0xa6c <vfprintf+0xe6>
 a18:	f3 2d       	mov	r31, r3
 a1a:	f8 60       	ori	r31, 0x08	; 8
 a1c:	1d c0       	rjmp	.+58     	; 0xa58 <vfprintf+0xd2>
 a1e:	37 fc       	sbrc	r3, 7
 a20:	2d c0       	rjmp	.+90     	; 0xa7c <vfprintf+0xf6>
 a22:	20 ed       	ldi	r18, 0xD0	; 208
 a24:	28 0f       	add	r18, r24
 a26:	2a 30       	cpi	r18, 0x0A	; 10
 a28:	40 f0       	brcs	.+16     	; 0xa3a <vfprintf+0xb4>
 a2a:	8e 32       	cpi	r24, 0x2E	; 46
 a2c:	b9 f4       	brne	.+46     	; 0xa5c <vfprintf+0xd6>
 a2e:	36 fc       	sbrc	r3, 6
 a30:	81 c1       	rjmp	.+770    	; 0xd34 <vfprintf+0x3ae>
 a32:	23 2d       	mov	r18, r3
 a34:	20 64       	ori	r18, 0x40	; 64
 a36:	32 2e       	mov	r3, r18
 a38:	19 c0       	rjmp	.+50     	; 0xa6c <vfprintf+0xe6>
 a3a:	36 fe       	sbrs	r3, 6
 a3c:	06 c0       	rjmp	.+12     	; 0xa4a <vfprintf+0xc4>
 a3e:	8a e0       	ldi	r24, 0x0A	; 10
 a40:	98 9e       	mul	r9, r24
 a42:	20 0d       	add	r18, r0
 a44:	11 24       	eor	r1, r1
 a46:	92 2e       	mov	r9, r18
 a48:	11 c0       	rjmp	.+34     	; 0xa6c <vfprintf+0xe6>
 a4a:	ea e0       	ldi	r30, 0x0A	; 10
 a4c:	2e 9e       	mul	r2, r30
 a4e:	20 0d       	add	r18, r0
 a50:	11 24       	eor	r1, r1
 a52:	22 2e       	mov	r2, r18
 a54:	f3 2d       	mov	r31, r3
 a56:	f0 62       	ori	r31, 0x20	; 32
 a58:	3f 2e       	mov	r3, r31
 a5a:	08 c0       	rjmp	.+16     	; 0xa6c <vfprintf+0xe6>
 a5c:	8c 36       	cpi	r24, 0x6C	; 108
 a5e:	21 f4       	brne	.+8      	; 0xa68 <vfprintf+0xe2>
 a60:	83 2d       	mov	r24, r3
 a62:	80 68       	ori	r24, 0x80	; 128
 a64:	38 2e       	mov	r3, r24
 a66:	02 c0       	rjmp	.+4      	; 0xa6c <vfprintf+0xe6>
 a68:	88 36       	cpi	r24, 0x68	; 104
 a6a:	41 f4       	brne	.+16     	; 0xa7c <vfprintf+0xf6>
 a6c:	f7 01       	movw	r30, r14
 a6e:	93 fd       	sbrc	r25, 3
 a70:	85 91       	lpm	r24, Z+
 a72:	93 ff       	sbrs	r25, 3
 a74:	81 91       	ld	r24, Z+
 a76:	7f 01       	movw	r14, r30
 a78:	81 11       	cpse	r24, r1
 a7a:	b3 cf       	rjmp	.-154    	; 0x9e2 <vfprintf+0x5c>
 a7c:	98 2f       	mov	r25, r24
 a7e:	9f 7d       	andi	r25, 0xDF	; 223
 a80:	95 54       	subi	r25, 0x45	; 69
 a82:	93 30       	cpi	r25, 0x03	; 3
 a84:	28 f4       	brcc	.+10     	; 0xa90 <vfprintf+0x10a>
 a86:	0c 5f       	subi	r16, 0xFC	; 252
 a88:	1f 4f       	sbci	r17, 0xFF	; 255
 a8a:	9f e3       	ldi	r25, 0x3F	; 63
 a8c:	99 83       	std	Y+1, r25	; 0x01
 a8e:	0d c0       	rjmp	.+26     	; 0xaaa <vfprintf+0x124>
 a90:	83 36       	cpi	r24, 0x63	; 99
 a92:	31 f0       	breq	.+12     	; 0xaa0 <vfprintf+0x11a>
 a94:	83 37       	cpi	r24, 0x73	; 115
 a96:	71 f0       	breq	.+28     	; 0xab4 <vfprintf+0x12e>
 a98:	83 35       	cpi	r24, 0x53	; 83
 a9a:	09 f0       	breq	.+2      	; 0xa9e <vfprintf+0x118>
 a9c:	59 c0       	rjmp	.+178    	; 0xb50 <vfprintf+0x1ca>
 a9e:	21 c0       	rjmp	.+66     	; 0xae2 <vfprintf+0x15c>
 aa0:	f8 01       	movw	r30, r16
 aa2:	80 81       	ld	r24, Z
 aa4:	89 83       	std	Y+1, r24	; 0x01
 aa6:	0e 5f       	subi	r16, 0xFE	; 254
 aa8:	1f 4f       	sbci	r17, 0xFF	; 255
 aaa:	88 24       	eor	r8, r8
 aac:	83 94       	inc	r8
 aae:	91 2c       	mov	r9, r1
 ab0:	53 01       	movw	r10, r6
 ab2:	13 c0       	rjmp	.+38     	; 0xada <vfprintf+0x154>
 ab4:	28 01       	movw	r4, r16
 ab6:	f2 e0       	ldi	r31, 0x02	; 2
 ab8:	4f 0e       	add	r4, r31
 aba:	51 1c       	adc	r5, r1
 abc:	f8 01       	movw	r30, r16
 abe:	a0 80       	ld	r10, Z
 ac0:	b1 80       	ldd	r11, Z+1	; 0x01
 ac2:	36 fe       	sbrs	r3, 6
 ac4:	03 c0       	rjmp	.+6      	; 0xacc <vfprintf+0x146>
 ac6:	69 2d       	mov	r22, r9
 ac8:	70 e0       	ldi	r23, 0x00	; 0
 aca:	02 c0       	rjmp	.+4      	; 0xad0 <vfprintf+0x14a>
 acc:	6f ef       	ldi	r22, 0xFF	; 255
 ace:	7f ef       	ldi	r23, 0xFF	; 255
 ad0:	c5 01       	movw	r24, r10
 ad2:	0e 94 af 06 	call	0xd5e	; 0xd5e <strnlen>
 ad6:	4c 01       	movw	r8, r24
 ad8:	82 01       	movw	r16, r4
 ada:	f3 2d       	mov	r31, r3
 adc:	ff 77       	andi	r31, 0x7F	; 127
 ade:	3f 2e       	mov	r3, r31
 ae0:	16 c0       	rjmp	.+44     	; 0xb0e <vfprintf+0x188>
 ae2:	28 01       	movw	r4, r16
 ae4:	22 e0       	ldi	r18, 0x02	; 2
 ae6:	42 0e       	add	r4, r18
 ae8:	51 1c       	adc	r5, r1
 aea:	f8 01       	movw	r30, r16
 aec:	a0 80       	ld	r10, Z
 aee:	b1 80       	ldd	r11, Z+1	; 0x01
 af0:	36 fe       	sbrs	r3, 6
 af2:	03 c0       	rjmp	.+6      	; 0xafa <vfprintf+0x174>
 af4:	69 2d       	mov	r22, r9
 af6:	70 e0       	ldi	r23, 0x00	; 0
 af8:	02 c0       	rjmp	.+4      	; 0xafe <vfprintf+0x178>
 afa:	6f ef       	ldi	r22, 0xFF	; 255
 afc:	7f ef       	ldi	r23, 0xFF	; 255
 afe:	c5 01       	movw	r24, r10
 b00:	0e 94 a4 06 	call	0xd48	; 0xd48 <strnlen_P>
 b04:	4c 01       	movw	r8, r24
 b06:	f3 2d       	mov	r31, r3
 b08:	f0 68       	ori	r31, 0x80	; 128
 b0a:	3f 2e       	mov	r3, r31
 b0c:	82 01       	movw	r16, r4
 b0e:	33 fc       	sbrc	r3, 3
 b10:	1b c0       	rjmp	.+54     	; 0xb48 <vfprintf+0x1c2>
 b12:	82 2d       	mov	r24, r2
 b14:	90 e0       	ldi	r25, 0x00	; 0
 b16:	88 16       	cp	r8, r24
 b18:	99 06       	cpc	r9, r25
 b1a:	b0 f4       	brcc	.+44     	; 0xb48 <vfprintf+0x1c2>
 b1c:	b6 01       	movw	r22, r12
 b1e:	80 e2       	ldi	r24, 0x20	; 32
 b20:	90 e0       	ldi	r25, 0x00	; 0
 b22:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 b26:	2a 94       	dec	r2
 b28:	f4 cf       	rjmp	.-24     	; 0xb12 <vfprintf+0x18c>
 b2a:	f5 01       	movw	r30, r10
 b2c:	37 fc       	sbrc	r3, 7
 b2e:	85 91       	lpm	r24, Z+
 b30:	37 fe       	sbrs	r3, 7
 b32:	81 91       	ld	r24, Z+
 b34:	5f 01       	movw	r10, r30
 b36:	b6 01       	movw	r22, r12
 b38:	90 e0       	ldi	r25, 0x00	; 0
 b3a:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 b3e:	21 10       	cpse	r2, r1
 b40:	2a 94       	dec	r2
 b42:	21 e0       	ldi	r18, 0x01	; 1
 b44:	82 1a       	sub	r8, r18
 b46:	91 08       	sbc	r9, r1
 b48:	81 14       	cp	r8, r1
 b4a:	91 04       	cpc	r9, r1
 b4c:	71 f7       	brne	.-36     	; 0xb2a <vfprintf+0x1a4>
 b4e:	e8 c0       	rjmp	.+464    	; 0xd20 <vfprintf+0x39a>
 b50:	84 36       	cpi	r24, 0x64	; 100
 b52:	11 f0       	breq	.+4      	; 0xb58 <vfprintf+0x1d2>
 b54:	89 36       	cpi	r24, 0x69	; 105
 b56:	41 f5       	brne	.+80     	; 0xba8 <vfprintf+0x222>
 b58:	f8 01       	movw	r30, r16
 b5a:	37 fe       	sbrs	r3, 7
 b5c:	07 c0       	rjmp	.+14     	; 0xb6c <vfprintf+0x1e6>
 b5e:	60 81       	ld	r22, Z
 b60:	71 81       	ldd	r23, Z+1	; 0x01
 b62:	82 81       	ldd	r24, Z+2	; 0x02
 b64:	93 81       	ldd	r25, Z+3	; 0x03
 b66:	0c 5f       	subi	r16, 0xFC	; 252
 b68:	1f 4f       	sbci	r17, 0xFF	; 255
 b6a:	08 c0       	rjmp	.+16     	; 0xb7c <vfprintf+0x1f6>
 b6c:	60 81       	ld	r22, Z
 b6e:	71 81       	ldd	r23, Z+1	; 0x01
 b70:	07 2e       	mov	r0, r23
 b72:	00 0c       	add	r0, r0
 b74:	88 0b       	sbc	r24, r24
 b76:	99 0b       	sbc	r25, r25
 b78:	0e 5f       	subi	r16, 0xFE	; 254
 b7a:	1f 4f       	sbci	r17, 0xFF	; 255
 b7c:	f3 2d       	mov	r31, r3
 b7e:	ff 76       	andi	r31, 0x6F	; 111
 b80:	3f 2e       	mov	r3, r31
 b82:	97 ff       	sbrs	r25, 7
 b84:	09 c0       	rjmp	.+18     	; 0xb98 <vfprintf+0x212>
 b86:	90 95       	com	r25
 b88:	80 95       	com	r24
 b8a:	70 95       	com	r23
 b8c:	61 95       	neg	r22
 b8e:	7f 4f       	sbci	r23, 0xFF	; 255
 b90:	8f 4f       	sbci	r24, 0xFF	; 255
 b92:	9f 4f       	sbci	r25, 0xFF	; 255
 b94:	f0 68       	ori	r31, 0x80	; 128
 b96:	3f 2e       	mov	r3, r31
 b98:	2a e0       	ldi	r18, 0x0A	; 10
 b9a:	30 e0       	ldi	r19, 0x00	; 0
 b9c:	a3 01       	movw	r20, r6
 b9e:	0e 94 f6 06 	call	0xdec	; 0xdec <__ultoa_invert>
 ba2:	88 2e       	mov	r8, r24
 ba4:	86 18       	sub	r8, r6
 ba6:	45 c0       	rjmp	.+138    	; 0xc32 <vfprintf+0x2ac>
 ba8:	85 37       	cpi	r24, 0x75	; 117
 baa:	31 f4       	brne	.+12     	; 0xbb8 <vfprintf+0x232>
 bac:	23 2d       	mov	r18, r3
 bae:	2f 7e       	andi	r18, 0xEF	; 239
 bb0:	b2 2e       	mov	r11, r18
 bb2:	2a e0       	ldi	r18, 0x0A	; 10
 bb4:	30 e0       	ldi	r19, 0x00	; 0
 bb6:	25 c0       	rjmp	.+74     	; 0xc02 <vfprintf+0x27c>
 bb8:	93 2d       	mov	r25, r3
 bba:	99 7f       	andi	r25, 0xF9	; 249
 bbc:	b9 2e       	mov	r11, r25
 bbe:	8f 36       	cpi	r24, 0x6F	; 111
 bc0:	c1 f0       	breq	.+48     	; 0xbf2 <vfprintf+0x26c>
 bc2:	18 f4       	brcc	.+6      	; 0xbca <vfprintf+0x244>
 bc4:	88 35       	cpi	r24, 0x58	; 88
 bc6:	79 f0       	breq	.+30     	; 0xbe6 <vfprintf+0x260>
 bc8:	b5 c0       	rjmp	.+362    	; 0xd34 <vfprintf+0x3ae>
 bca:	80 37       	cpi	r24, 0x70	; 112
 bcc:	19 f0       	breq	.+6      	; 0xbd4 <vfprintf+0x24e>
 bce:	88 37       	cpi	r24, 0x78	; 120
 bd0:	21 f0       	breq	.+8      	; 0xbda <vfprintf+0x254>
 bd2:	b0 c0       	rjmp	.+352    	; 0xd34 <vfprintf+0x3ae>
 bd4:	e9 2f       	mov	r30, r25
 bd6:	e0 61       	ori	r30, 0x10	; 16
 bd8:	be 2e       	mov	r11, r30
 bda:	b4 fe       	sbrs	r11, 4
 bdc:	0d c0       	rjmp	.+26     	; 0xbf8 <vfprintf+0x272>
 bde:	fb 2d       	mov	r31, r11
 be0:	f4 60       	ori	r31, 0x04	; 4
 be2:	bf 2e       	mov	r11, r31
 be4:	09 c0       	rjmp	.+18     	; 0xbf8 <vfprintf+0x272>
 be6:	34 fe       	sbrs	r3, 4
 be8:	0a c0       	rjmp	.+20     	; 0xbfe <vfprintf+0x278>
 bea:	29 2f       	mov	r18, r25
 bec:	26 60       	ori	r18, 0x06	; 6
 bee:	b2 2e       	mov	r11, r18
 bf0:	06 c0       	rjmp	.+12     	; 0xbfe <vfprintf+0x278>
 bf2:	28 e0       	ldi	r18, 0x08	; 8
 bf4:	30 e0       	ldi	r19, 0x00	; 0
 bf6:	05 c0       	rjmp	.+10     	; 0xc02 <vfprintf+0x27c>
 bf8:	20 e1       	ldi	r18, 0x10	; 16
 bfa:	30 e0       	ldi	r19, 0x00	; 0
 bfc:	02 c0       	rjmp	.+4      	; 0xc02 <vfprintf+0x27c>
 bfe:	20 e1       	ldi	r18, 0x10	; 16
 c00:	32 e0       	ldi	r19, 0x02	; 2
 c02:	f8 01       	movw	r30, r16
 c04:	b7 fe       	sbrs	r11, 7
 c06:	07 c0       	rjmp	.+14     	; 0xc16 <vfprintf+0x290>
 c08:	60 81       	ld	r22, Z
 c0a:	71 81       	ldd	r23, Z+1	; 0x01
 c0c:	82 81       	ldd	r24, Z+2	; 0x02
 c0e:	93 81       	ldd	r25, Z+3	; 0x03
 c10:	0c 5f       	subi	r16, 0xFC	; 252
 c12:	1f 4f       	sbci	r17, 0xFF	; 255
 c14:	06 c0       	rjmp	.+12     	; 0xc22 <vfprintf+0x29c>
 c16:	60 81       	ld	r22, Z
 c18:	71 81       	ldd	r23, Z+1	; 0x01
 c1a:	80 e0       	ldi	r24, 0x00	; 0
 c1c:	90 e0       	ldi	r25, 0x00	; 0
 c1e:	0e 5f       	subi	r16, 0xFE	; 254
 c20:	1f 4f       	sbci	r17, 0xFF	; 255
 c22:	a3 01       	movw	r20, r6
 c24:	0e 94 f6 06 	call	0xdec	; 0xdec <__ultoa_invert>
 c28:	88 2e       	mov	r8, r24
 c2a:	86 18       	sub	r8, r6
 c2c:	fb 2d       	mov	r31, r11
 c2e:	ff 77       	andi	r31, 0x7F	; 127
 c30:	3f 2e       	mov	r3, r31
 c32:	36 fe       	sbrs	r3, 6
 c34:	0d c0       	rjmp	.+26     	; 0xc50 <vfprintf+0x2ca>
 c36:	23 2d       	mov	r18, r3
 c38:	2e 7f       	andi	r18, 0xFE	; 254
 c3a:	a2 2e       	mov	r10, r18
 c3c:	89 14       	cp	r8, r9
 c3e:	58 f4       	brcc	.+22     	; 0xc56 <vfprintf+0x2d0>
 c40:	34 fe       	sbrs	r3, 4
 c42:	0b c0       	rjmp	.+22     	; 0xc5a <vfprintf+0x2d4>
 c44:	32 fc       	sbrc	r3, 2
 c46:	09 c0       	rjmp	.+18     	; 0xc5a <vfprintf+0x2d4>
 c48:	83 2d       	mov	r24, r3
 c4a:	8e 7e       	andi	r24, 0xEE	; 238
 c4c:	a8 2e       	mov	r10, r24
 c4e:	05 c0       	rjmp	.+10     	; 0xc5a <vfprintf+0x2d4>
 c50:	b8 2c       	mov	r11, r8
 c52:	a3 2c       	mov	r10, r3
 c54:	03 c0       	rjmp	.+6      	; 0xc5c <vfprintf+0x2d6>
 c56:	b8 2c       	mov	r11, r8
 c58:	01 c0       	rjmp	.+2      	; 0xc5c <vfprintf+0x2d6>
 c5a:	b9 2c       	mov	r11, r9
 c5c:	a4 fe       	sbrs	r10, 4
 c5e:	0f c0       	rjmp	.+30     	; 0xc7e <vfprintf+0x2f8>
 c60:	fe 01       	movw	r30, r28
 c62:	e8 0d       	add	r30, r8
 c64:	f1 1d       	adc	r31, r1
 c66:	80 81       	ld	r24, Z
 c68:	80 33       	cpi	r24, 0x30	; 48
 c6a:	21 f4       	brne	.+8      	; 0xc74 <vfprintf+0x2ee>
 c6c:	9a 2d       	mov	r25, r10
 c6e:	99 7e       	andi	r25, 0xE9	; 233
 c70:	a9 2e       	mov	r10, r25
 c72:	09 c0       	rjmp	.+18     	; 0xc86 <vfprintf+0x300>
 c74:	a2 fe       	sbrs	r10, 2
 c76:	06 c0       	rjmp	.+12     	; 0xc84 <vfprintf+0x2fe>
 c78:	b3 94       	inc	r11
 c7a:	b3 94       	inc	r11
 c7c:	04 c0       	rjmp	.+8      	; 0xc86 <vfprintf+0x300>
 c7e:	8a 2d       	mov	r24, r10
 c80:	86 78       	andi	r24, 0x86	; 134
 c82:	09 f0       	breq	.+2      	; 0xc86 <vfprintf+0x300>
 c84:	b3 94       	inc	r11
 c86:	a3 fc       	sbrc	r10, 3
 c88:	11 c0       	rjmp	.+34     	; 0xcac <vfprintf+0x326>
 c8a:	a0 fe       	sbrs	r10, 0
 c8c:	06 c0       	rjmp	.+12     	; 0xc9a <vfprintf+0x314>
 c8e:	b2 14       	cp	r11, r2
 c90:	88 f4       	brcc	.+34     	; 0xcb4 <vfprintf+0x32e>
 c92:	28 0c       	add	r2, r8
 c94:	92 2c       	mov	r9, r2
 c96:	9b 18       	sub	r9, r11
 c98:	0e c0       	rjmp	.+28     	; 0xcb6 <vfprintf+0x330>
 c9a:	b2 14       	cp	r11, r2
 c9c:	60 f4       	brcc	.+24     	; 0xcb6 <vfprintf+0x330>
 c9e:	b6 01       	movw	r22, r12
 ca0:	80 e2       	ldi	r24, 0x20	; 32
 ca2:	90 e0       	ldi	r25, 0x00	; 0
 ca4:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 ca8:	b3 94       	inc	r11
 caa:	f7 cf       	rjmp	.-18     	; 0xc9a <vfprintf+0x314>
 cac:	b2 14       	cp	r11, r2
 cae:	18 f4       	brcc	.+6      	; 0xcb6 <vfprintf+0x330>
 cb0:	2b 18       	sub	r2, r11
 cb2:	02 c0       	rjmp	.+4      	; 0xcb8 <vfprintf+0x332>
 cb4:	98 2c       	mov	r9, r8
 cb6:	21 2c       	mov	r2, r1
 cb8:	a4 fe       	sbrs	r10, 4
 cba:	10 c0       	rjmp	.+32     	; 0xcdc <vfprintf+0x356>
 cbc:	b6 01       	movw	r22, r12
 cbe:	80 e3       	ldi	r24, 0x30	; 48
 cc0:	90 e0       	ldi	r25, 0x00	; 0
 cc2:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 cc6:	a2 fe       	sbrs	r10, 2
 cc8:	17 c0       	rjmp	.+46     	; 0xcf8 <vfprintf+0x372>
 cca:	a1 fc       	sbrc	r10, 1
 ccc:	03 c0       	rjmp	.+6      	; 0xcd4 <vfprintf+0x34e>
 cce:	88 e7       	ldi	r24, 0x78	; 120
 cd0:	90 e0       	ldi	r25, 0x00	; 0
 cd2:	02 c0       	rjmp	.+4      	; 0xcd8 <vfprintf+0x352>
 cd4:	88 e5       	ldi	r24, 0x58	; 88
 cd6:	90 e0       	ldi	r25, 0x00	; 0
 cd8:	b6 01       	movw	r22, r12
 cda:	0c c0       	rjmp	.+24     	; 0xcf4 <vfprintf+0x36e>
 cdc:	8a 2d       	mov	r24, r10
 cde:	86 78       	andi	r24, 0x86	; 134
 ce0:	59 f0       	breq	.+22     	; 0xcf8 <vfprintf+0x372>
 ce2:	a1 fe       	sbrs	r10, 1
 ce4:	02 c0       	rjmp	.+4      	; 0xcea <vfprintf+0x364>
 ce6:	8b e2       	ldi	r24, 0x2B	; 43
 ce8:	01 c0       	rjmp	.+2      	; 0xcec <vfprintf+0x366>
 cea:	80 e2       	ldi	r24, 0x20	; 32
 cec:	a7 fc       	sbrc	r10, 7
 cee:	8d e2       	ldi	r24, 0x2D	; 45
 cf0:	b6 01       	movw	r22, r12
 cf2:	90 e0       	ldi	r25, 0x00	; 0
 cf4:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 cf8:	89 14       	cp	r8, r9
 cfa:	38 f4       	brcc	.+14     	; 0xd0a <vfprintf+0x384>
 cfc:	b6 01       	movw	r22, r12
 cfe:	80 e3       	ldi	r24, 0x30	; 48
 d00:	90 e0       	ldi	r25, 0x00	; 0
 d02:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 d06:	9a 94       	dec	r9
 d08:	f7 cf       	rjmp	.-18     	; 0xcf8 <vfprintf+0x372>
 d0a:	8a 94       	dec	r8
 d0c:	f3 01       	movw	r30, r6
 d0e:	e8 0d       	add	r30, r8
 d10:	f1 1d       	adc	r31, r1
 d12:	80 81       	ld	r24, Z
 d14:	b6 01       	movw	r22, r12
 d16:	90 e0       	ldi	r25, 0x00	; 0
 d18:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 d1c:	81 10       	cpse	r8, r1
 d1e:	f5 cf       	rjmp	.-22     	; 0xd0a <vfprintf+0x384>
 d20:	22 20       	and	r2, r2
 d22:	09 f4       	brne	.+2      	; 0xd26 <vfprintf+0x3a0>
 d24:	42 ce       	rjmp	.-892    	; 0x9aa <vfprintf+0x24>
 d26:	b6 01       	movw	r22, r12
 d28:	80 e2       	ldi	r24, 0x20	; 32
 d2a:	90 e0       	ldi	r25, 0x00	; 0
 d2c:	0e 94 ba 06 	call	0xd74	; 0xd74 <fputc>
 d30:	2a 94       	dec	r2
 d32:	f6 cf       	rjmp	.-20     	; 0xd20 <vfprintf+0x39a>
 d34:	f6 01       	movw	r30, r12
 d36:	86 81       	ldd	r24, Z+6	; 0x06
 d38:	97 81       	ldd	r25, Z+7	; 0x07
 d3a:	02 c0       	rjmp	.+4      	; 0xd40 <vfprintf+0x3ba>
 d3c:	8f ef       	ldi	r24, 0xFF	; 255
 d3e:	9f ef       	ldi	r25, 0xFF	; 255
 d40:	2b 96       	adiw	r28, 0x0b	; 11
 d42:	e2 e1       	ldi	r30, 0x12	; 18
 d44:	0c 94 70 07 	jmp	0xee0	; 0xee0 <__epilogue_restores__>

00000d48 <strnlen_P>:
 d48:	fc 01       	movw	r30, r24
 d4a:	05 90       	lpm	r0, Z+
 d4c:	61 50       	subi	r22, 0x01	; 1
 d4e:	70 40       	sbci	r23, 0x00	; 0
 d50:	01 10       	cpse	r0, r1
 d52:	d8 f7       	brcc	.-10     	; 0xd4a <strnlen_P+0x2>
 d54:	80 95       	com	r24
 d56:	90 95       	com	r25
 d58:	8e 0f       	add	r24, r30
 d5a:	9f 1f       	adc	r25, r31
 d5c:	08 95       	ret

00000d5e <strnlen>:
 d5e:	fc 01       	movw	r30, r24
 d60:	61 50       	subi	r22, 0x01	; 1
 d62:	70 40       	sbci	r23, 0x00	; 0
 d64:	01 90       	ld	r0, Z+
 d66:	01 10       	cpse	r0, r1
 d68:	d8 f7       	brcc	.-10     	; 0xd60 <strnlen+0x2>
 d6a:	80 95       	com	r24
 d6c:	90 95       	com	r25
 d6e:	8e 0f       	add	r24, r30
 d70:	9f 1f       	adc	r25, r31
 d72:	08 95       	ret

00000d74 <fputc>:
 d74:	0f 93       	push	r16
 d76:	1f 93       	push	r17
 d78:	cf 93       	push	r28
 d7a:	df 93       	push	r29
 d7c:	fb 01       	movw	r30, r22
 d7e:	23 81       	ldd	r18, Z+3	; 0x03
 d80:	21 fd       	sbrc	r18, 1
 d82:	03 c0       	rjmp	.+6      	; 0xd8a <fputc+0x16>
 d84:	8f ef       	ldi	r24, 0xFF	; 255
 d86:	9f ef       	ldi	r25, 0xFF	; 255
 d88:	2c c0       	rjmp	.+88     	; 0xde2 <fputc+0x6e>
 d8a:	22 ff       	sbrs	r18, 2
 d8c:	16 c0       	rjmp	.+44     	; 0xdba <fputc+0x46>
 d8e:	46 81       	ldd	r20, Z+6	; 0x06
 d90:	57 81       	ldd	r21, Z+7	; 0x07
 d92:	24 81       	ldd	r18, Z+4	; 0x04
 d94:	35 81       	ldd	r19, Z+5	; 0x05
 d96:	42 17       	cp	r20, r18
 d98:	53 07       	cpc	r21, r19
 d9a:	44 f4       	brge	.+16     	; 0xdac <fputc+0x38>
 d9c:	a0 81       	ld	r26, Z
 d9e:	b1 81       	ldd	r27, Z+1	; 0x01
 da0:	9d 01       	movw	r18, r26
 da2:	2f 5f       	subi	r18, 0xFF	; 255
 da4:	3f 4f       	sbci	r19, 0xFF	; 255
 da6:	31 83       	std	Z+1, r19	; 0x01
 da8:	20 83       	st	Z, r18
 daa:	8c 93       	st	X, r24
 dac:	26 81       	ldd	r18, Z+6	; 0x06
 dae:	37 81       	ldd	r19, Z+7	; 0x07
 db0:	2f 5f       	subi	r18, 0xFF	; 255
 db2:	3f 4f       	sbci	r19, 0xFF	; 255
 db4:	37 83       	std	Z+7, r19	; 0x07
 db6:	26 83       	std	Z+6, r18	; 0x06
 db8:	14 c0       	rjmp	.+40     	; 0xde2 <fputc+0x6e>
 dba:	8b 01       	movw	r16, r22
 dbc:	ec 01       	movw	r28, r24
 dbe:	fb 01       	movw	r30, r22
 dc0:	00 84       	ldd	r0, Z+8	; 0x08
 dc2:	f1 85       	ldd	r31, Z+9	; 0x09
 dc4:	e0 2d       	mov	r30, r0
 dc6:	09 95       	icall
 dc8:	89 2b       	or	r24, r25
 dca:	e1 f6       	brne	.-72     	; 0xd84 <fputc+0x10>
 dcc:	d8 01       	movw	r26, r16
 dce:	16 96       	adiw	r26, 0x06	; 6
 dd0:	8d 91       	ld	r24, X+
 dd2:	9c 91       	ld	r25, X
 dd4:	17 97       	sbiw	r26, 0x07	; 7
 dd6:	01 96       	adiw	r24, 0x01	; 1
 dd8:	17 96       	adiw	r26, 0x07	; 7
 dda:	9c 93       	st	X, r25
 ddc:	8e 93       	st	-X, r24
 dde:	16 97       	sbiw	r26, 0x06	; 6
 de0:	ce 01       	movw	r24, r28
 de2:	df 91       	pop	r29
 de4:	cf 91       	pop	r28
 de6:	1f 91       	pop	r17
 de8:	0f 91       	pop	r16
 dea:	08 95       	ret

00000dec <__ultoa_invert>:
 dec:	fa 01       	movw	r30, r20
 dee:	aa 27       	eor	r26, r26
 df0:	28 30       	cpi	r18, 0x08	; 8
 df2:	51 f1       	breq	.+84     	; 0xe48 <__ultoa_invert+0x5c>
 df4:	20 31       	cpi	r18, 0x10	; 16
 df6:	81 f1       	breq	.+96     	; 0xe58 <__ultoa_invert+0x6c>
 df8:	e8 94       	clt
 dfa:	6f 93       	push	r22
 dfc:	6e 7f       	andi	r22, 0xFE	; 254
 dfe:	6e 5f       	subi	r22, 0xFE	; 254
 e00:	7f 4f       	sbci	r23, 0xFF	; 255
 e02:	8f 4f       	sbci	r24, 0xFF	; 255
 e04:	9f 4f       	sbci	r25, 0xFF	; 255
 e06:	af 4f       	sbci	r26, 0xFF	; 255
 e08:	b1 e0       	ldi	r27, 0x01	; 1
 e0a:	3e d0       	rcall	.+124    	; 0xe88 <__ultoa_invert+0x9c>
 e0c:	b4 e0       	ldi	r27, 0x04	; 4
 e0e:	3c d0       	rcall	.+120    	; 0xe88 <__ultoa_invert+0x9c>
 e10:	67 0f       	add	r22, r23
 e12:	78 1f       	adc	r23, r24
 e14:	89 1f       	adc	r24, r25
 e16:	9a 1f       	adc	r25, r26
 e18:	a1 1d       	adc	r26, r1
 e1a:	68 0f       	add	r22, r24
 e1c:	79 1f       	adc	r23, r25
 e1e:	8a 1f       	adc	r24, r26
 e20:	91 1d       	adc	r25, r1
 e22:	a1 1d       	adc	r26, r1
 e24:	6a 0f       	add	r22, r26
 e26:	71 1d       	adc	r23, r1
 e28:	81 1d       	adc	r24, r1
 e2a:	91 1d       	adc	r25, r1
 e2c:	a1 1d       	adc	r26, r1
 e2e:	20 d0       	rcall	.+64     	; 0xe70 <__ultoa_invert+0x84>
 e30:	09 f4       	brne	.+2      	; 0xe34 <__ultoa_invert+0x48>
 e32:	68 94       	set
 e34:	3f 91       	pop	r19
 e36:	2a e0       	ldi	r18, 0x0A	; 10
 e38:	26 9f       	mul	r18, r22
 e3a:	11 24       	eor	r1, r1
 e3c:	30 19       	sub	r19, r0
 e3e:	30 5d       	subi	r19, 0xD0	; 208
 e40:	31 93       	st	Z+, r19
 e42:	de f6       	brtc	.-74     	; 0xdfa <__ultoa_invert+0xe>
 e44:	cf 01       	movw	r24, r30
 e46:	08 95       	ret
 e48:	46 2f       	mov	r20, r22
 e4a:	47 70       	andi	r20, 0x07	; 7
 e4c:	40 5d       	subi	r20, 0xD0	; 208
 e4e:	41 93       	st	Z+, r20
 e50:	b3 e0       	ldi	r27, 0x03	; 3
 e52:	0f d0       	rcall	.+30     	; 0xe72 <__ultoa_invert+0x86>
 e54:	c9 f7       	brne	.-14     	; 0xe48 <__ultoa_invert+0x5c>
 e56:	f6 cf       	rjmp	.-20     	; 0xe44 <__ultoa_invert+0x58>
 e58:	46 2f       	mov	r20, r22
 e5a:	4f 70       	andi	r20, 0x0F	; 15
 e5c:	40 5d       	subi	r20, 0xD0	; 208
 e5e:	4a 33       	cpi	r20, 0x3A	; 58
 e60:	18 f0       	brcs	.+6      	; 0xe68 <__ultoa_invert+0x7c>
 e62:	49 5d       	subi	r20, 0xD9	; 217
 e64:	31 fd       	sbrc	r19, 1
 e66:	40 52       	subi	r20, 0x20	; 32
 e68:	41 93       	st	Z+, r20
 e6a:	02 d0       	rcall	.+4      	; 0xe70 <__ultoa_invert+0x84>
 e6c:	a9 f7       	brne	.-22     	; 0xe58 <__ultoa_invert+0x6c>
 e6e:	ea cf       	rjmp	.-44     	; 0xe44 <__ultoa_invert+0x58>
 e70:	b4 e0       	ldi	r27, 0x04	; 4
 e72:	a6 95       	lsr	r26
 e74:	97 95       	ror	r25
 e76:	87 95       	ror	r24
 e78:	77 95       	ror	r23
 e7a:	67 95       	ror	r22
 e7c:	ba 95       	dec	r27
 e7e:	c9 f7       	brne	.-14     	; 0xe72 <__ultoa_invert+0x86>
 e80:	00 97       	sbiw	r24, 0x00	; 0
 e82:	61 05       	cpc	r22, r1
 e84:	71 05       	cpc	r23, r1
 e86:	08 95       	ret
 e88:	9b 01       	movw	r18, r22
 e8a:	ac 01       	movw	r20, r24
 e8c:	0a 2e       	mov	r0, r26
 e8e:	06 94       	lsr	r0
 e90:	57 95       	ror	r21
 e92:	47 95       	ror	r20
 e94:	37 95       	ror	r19
 e96:	27 95       	ror	r18
 e98:	ba 95       	dec	r27
 e9a:	c9 f7       	brne	.-14     	; 0xe8e <__ultoa_invert+0xa2>
 e9c:	62 0f       	add	r22, r18
 e9e:	73 1f       	adc	r23, r19
 ea0:	84 1f       	adc	r24, r20
 ea2:	95 1f       	adc	r25, r21
 ea4:	a0 1d       	adc	r26, r0
 ea6:	08 95       	ret

00000ea8 <__prologue_saves__>:
 ea8:	2f 92       	push	r2
 eaa:	3f 92       	push	r3
 eac:	4f 92       	push	r4
 eae:	5f 92       	push	r5
 eb0:	6f 92       	push	r6
 eb2:	7f 92       	push	r7
 eb4:	8f 92       	push	r8
 eb6:	9f 92       	push	r9
 eb8:	af 92       	push	r10
 eba:	bf 92       	push	r11
 ebc:	cf 92       	push	r12
 ebe:	df 92       	push	r13
 ec0:	ef 92       	push	r14
 ec2:	ff 92       	push	r15
 ec4:	0f 93       	push	r16
 ec6:	1f 93       	push	r17
 ec8:	cf 93       	push	r28
 eca:	df 93       	push	r29
 ecc:	cd b7       	in	r28, 0x3d	; 61
 ece:	de b7       	in	r29, 0x3e	; 62
 ed0:	ca 1b       	sub	r28, r26
 ed2:	db 0b       	sbc	r29, r27
 ed4:	0f b6       	in	r0, 0x3f	; 63
 ed6:	f8 94       	cli
 ed8:	de bf       	out	0x3e, r29	; 62
 eda:	0f be       	out	0x3f, r0	; 63
 edc:	cd bf       	out	0x3d, r28	; 61
 ede:	09 94       	ijmp

00000ee0 <__epilogue_restores__>:
 ee0:	2a 88       	ldd	r2, Y+18	; 0x12
 ee2:	39 88       	ldd	r3, Y+17	; 0x11
 ee4:	48 88       	ldd	r4, Y+16	; 0x10
 ee6:	5f 84       	ldd	r5, Y+15	; 0x0f
 ee8:	6e 84       	ldd	r6, Y+14	; 0x0e
 eea:	7d 84       	ldd	r7, Y+13	; 0x0d
 eec:	8c 84       	ldd	r8, Y+12	; 0x0c
 eee:	9b 84       	ldd	r9, Y+11	; 0x0b
 ef0:	aa 84       	ldd	r10, Y+10	; 0x0a
 ef2:	b9 84       	ldd	r11, Y+9	; 0x09
 ef4:	c8 84       	ldd	r12, Y+8	; 0x08
 ef6:	df 80       	ldd	r13, Y+7	; 0x07
 ef8:	ee 80       	ldd	r14, Y+6	; 0x06
 efa:	fd 80       	ldd	r15, Y+5	; 0x05
 efc:	0c 81       	ldd	r16, Y+4	; 0x04
 efe:	1b 81       	ldd	r17, Y+3	; 0x03
 f00:	aa 81       	ldd	r26, Y+2	; 0x02
 f02:	b9 81       	ldd	r27, Y+1	; 0x01
 f04:	ce 0f       	add	r28, r30
 f06:	d1 1d       	adc	r29, r1
 f08:	0f b6       	in	r0, 0x3f	; 63
 f0a:	f8 94       	cli
 f0c:	de bf       	out	0x3e, r29	; 62
 f0e:	0f be       	out	0x3f, r0	; 63
 f10:	cd bf       	out	0x3d, r28	; 61
 f12:	ed 01       	movw	r28, r26
 f14:	08 95       	ret

00000f16 <_exit>:
 f16:	f8 94       	cli

00000f18 <__stop_program>:
 f18:	ff cf       	rjmp	.-2      	; 0xf18 <__stop_program>
